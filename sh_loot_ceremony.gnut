
global function LootBoxCeremony_SharedInit













































global function InitLootBoxMenu
global function OnLobbyOpenLootBoxMenu_ButtonPress

global function ClientToUI_UpdateSpecialItemPresentationPurchaseButton
global function ClientToUI_EquipButtonShowDialog
global function ClientToUI_EquipToWheelButtonShowDialog
global function ClientToUI_SetLootHasBeenPresented
global function ClientToUI_UpdateStoreButtonVisibility
global function ClientToUI_SetInspectModeIsActive
global function ClientToUI_ClearInspectModeIsActive
global function ClientToUI_PlayLootCeremonySound
global function ClientToUI_StopLootCeremonySound
global function ClientToUI_LootCeremonyMarkItemAsNoLongerNew
global function ClientToUI_TrackMythicChallenge

global function LootCeremony_UpdateOpenAdditionalButton

global function InspectItemTypePresentationSupported
global function SetStoreItemPresentationModeActive
global function SetBattlePassItemPresentationModeActive
global function SetTreasurePackItemPresentationModeActive
global function SetGenericItemPresentationModeActiveWithNavBack
global function SetCollectionEventItemPresentationModeActive
global function SetChallengeRewardPresentationModeActive
global function GetNextLootBox

global function ForceOpenRewardPacks



global function IsItemEquipped
global function GetCurrentlyEquippedItemNameForItemTypeSlot
global function GetCurrentlyEquippedItemRarityForItemTypeSlot
global function EquipButton_GetItemLoadoutEntries

































































































struct FileForeverStruct
{
	table signalDummy

	var menu
	var inspectMenu
	var equipButton
	var equipToWheelButton
	var purchaseButton
	var trackChallengeButton
	var mouseClickElem
	var inspectVideoPanel
	var storeButton
	var lootBoxOpenButton
	var inspectRewardButton1
	var inspectRewardButton2
	var inspectRewardButton3
	var skipAnimButton
	var blackFlash

		var battlePassButton

}
FileForeverStruct& fileForever



enum eCeremonyPresentationMode
{
	APEX_PACK,
	STORE_ITEM,
	BATTLE_PASS,
}


struct FileLevelStruct
{

























































		bool						heirloomShards = false

		ItemFlavor ornull       	forceParticularPackFlav = null
		bool                    	lootHasBeenPresented = false
		bool                    	considerFocusOpenButton = false
		bool                    	inspectModeActive = false
		bool                    	specialItemPresentationModeActive = false
		GRXScriptOffer ornull   	storeItemPresentationModeOffer
		ItemFlavor&             	specialItemPresentationModeItemFlav
		int                     	specialItemPresentationModeItemQty
		int                     	specialItemPresentationModeItemBadgeTier
		ItemFlavor ornull       	storeItemPresentationModeItemPrereq = null
		string                  	specialItemFormattedPrice = ""
		bool ornull             	specialItemOverrideOwned = null
		bool                    	specialItemHideEquipButton = false
		bool                    	specialItemHidePurchaseButton = false
		string                  	specialItemPriceHeader = ""
		bool                    	specialItemLockPurchaseButton = false
		string ornull           	specialItemPackName = null
		asset ornull            	specialItemPackImg = null
		PurchaseDialogConfig ornull	specialPurchaseDialogConfig = null
		void functionref()			onNavigatingBackFunc = null

			bool						isBpRewardPremium = false
			bool						isBpOwned = false


}
FileLevelStruct& fileLevel


void function LootBoxCeremony_SharedInit()
{
	Remote_RegisterServerFunction( "Server_GrantLegendaryStickersIfCollectionCompleted" )
	Remote_RegisterUIFunction( "ForceOpenRewardPacks" )
}
























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































const float REWARDS_DELAY_TIER5 = 1.1
const float REWARDS_DELAY_TIER4 = 1.0
const float REWARDS_DELAY_TIER3 = 0.4
const float REWARDS_DELAY_TIER1 = 0.2
















































































































































































































const float MODEL_ROTATE_SPEED = 15.0
const float CURRENCY_Z_OFFSET = 26.0
















































































































































const float CHARACTER_SKIN_Z_OFFSET = 4.0
const float CHARACTER_SKIN_SCALE = 0.7


















































const float EXECUTION_Z_OFFSET = 12.0
const vector EXECUTION_LOCAL_ANGLES = <0, 15, 0>
const float EXECUTION_SCALE = 0.4
























































































const float WEAPON_SKIN_Z_OFFSET = 28.0
const vector WEAPON_SKIN_LOCAL_ANGLES = <10, -90, 0>






































































































































const float WEAPON_CHARM_Z_OFFSET = 32.0
const vector WEAPON_CHARM_LOCAL_ANGLES = <-5, -40, 0>
const float WEAPON_CHARM_BASE_SCALE = 1.0
const float WEAPON_CHARM_EXTRA_SCALE = 1.34
































































































































const float GLADIATOR_CARD_WIDTH = 528.0
const float GLADIATOR_CARD_HEIGHT = 912.0
const float GLADIATOR_CARD_Z_OFFSET = 2.0
























































































const float RUI_QUIP_WIDTH = 390.0
const float RUI_QUIP_HEIGHT = 208.0
const float RUI_QUIP_Z_OFFSET = 24.0
















































































































const float STAT_TRACKER_WIDTH = 594.0
const float STAT_TRACKER_HEIGHT = 230.0
const float STAT_TRACKER_Z_OFFSET = 27.0
const float STAT_TRACKER_SCALE_DIVIDE_BY = 24.0


















































const float BADGE_Z_OFFSET = 20.0
























































































































































































































































































































































const float RUI_PLACARD_WIDTH 			= 550.0
const float RUI_PLACARD_HEIGHT 			= 256.0
const float RUI_PLACARD_Z_OFFSET		= 7.0
const float RUI_PLACARD_FORWARD_OFFSET 	= 32.0
const bool  RUI_PLACARD_DEBUG 			= false
const int   MYTHIC_RARITY_INDEX 		= eRarityTier.MYTHIC + 1 











































































































































































































































































































































































const float INSPECT_ZOOM_TIME = 0.25











































































































































































































array<LoadoutEntry> function EquipButton_GetItemLoadoutEntries( ItemFlavor item, bool statTrackerFindExistingEntry = false )
{
	int itemType = ItemFlavor_GetType( item )
	array<LoadoutEntry> loadoutEntries

	switch ( itemType )
	{
		case eItemType.character_skin:
			loadoutEntries = [ Loadout_CharacterSkin( CharacterSkin_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.weapon_skin:
			loadoutEntries = [ Loadout_WeaponSkin( WeaponSkin_GetWeaponFlavor( item ) ) ]
			break

		case eItemType.gladiator_card_frame:
			ItemFlavor ornull character = GladiatorCardFrame_GetCharacterFlavor( item )
			if ( character == null ) 
				character = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() )
			expect ItemFlavor( character )

			loadoutEntries = [ Loadout_GladiatorCardFrame( character ) ]
			break

		case eItemType.gladiator_card_stance:
			loadoutEntries = [ Loadout_GladiatorCardStance( GladiatorCardStance_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.character_execution:
			loadoutEntries = [ Loadout_CharacterExecution( CharacterExecution_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.gladiator_card_intro_quip:
			loadoutEntries = [ Loadout_CharacterIntroQuip( CharacterIntroQuip_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.gladiator_card_kill_quip:
			loadoutEntries = [ Loadout_CharacterKillQuip( CharacterKillQuip_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.gladiator_card_stat_tracker:
			if ( statTrackerFindExistingEntry )
			{
				loadoutEntries = [ PopulateInspectMenuDetails_GetStatTrackerLoadoutEntry( item, statTrackerFindExistingEntry ) ]
			}
			else
			{
				ItemFlavor ornull character = GladiatorCardStatTracker_GetCharacterFlavor( item )
				if ( character == null ) 
					character = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() )

				expect ItemFlavor( character )

				for ( int trackerIndex = 0; trackerIndex < GLADIATOR_CARDS_NUM_TRACKERS; trackerIndex++ )
				{
					LoadoutEntry trackerSlot = Loadout_GladiatorCardStatTracker( character, trackerIndex )
					if ( LoadoutSlot_IsReady( LocalClientEHI(), trackerSlot ) )
						loadoutEntries.append( trackerSlot )
				}
			}
			break

		case eItemType.melee_skin:
			loadoutEntries = [ Loadout_MeleeSkin( MeleeSkin_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.gladiator_card_badge:
			ItemFlavor character = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() )

			for ( int badgeIndex = 0; badgeIndex < GLADIATOR_CARDS_NUM_BADGES; badgeIndex++ )
			{
				LoadoutEntry badgeSlot = Loadout_GladiatorCardStatTracker( character, badgeIndex )
				if ( LoadoutSlot_IsReady( LocalClientEHI(), badgeSlot ) )
					loadoutEntries.append( badgeSlot )
			}
			break

		case eItemType.music_pack:
			loadoutEntries = [ Loadout_MusicPack() ]
			break

		case eItemType.loadscreen:
			loadoutEntries = [ Loadout_Loadscreen() ]
			break

		case eItemType.skydive_trail:
			loadoutEntries = [ Loadout_SkydiveTrail() ]
			break

		case eItemType.skydive_emote:
			ItemFlavor character = SkydiveEmote_GetCharacterFlavor( item )

			for ( int emoteIndex = 0; emoteIndex < NUM_SKYDIVE_EMOTE_SLOTS; emoteIndex++ )
			{
				LoadoutEntry emoteSlot = Loadout_SkydiveEmote( character, emoteIndex )
				if ( LoadoutSlot_IsReady( LocalClientEHI(), emoteSlot ) )
					loadoutEntries.append( emoteSlot )
			}
			break

		case eItemType.emote_icon:
		case eItemType.character_emote:
			ItemFlavor ornull character = CharacterQuip_GetCharacterFlavor( item )
			if ( character == null ) 
				character = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() )
			expect ItemFlavor( character )

			for ( int emoteIndex = 0; emoteIndex < MAX_QUIPS_EQUIPPED; emoteIndex++ )
			{
				LoadoutEntry emoteSlot = Loadout_CharacterQuip( character, emoteIndex )
				if ( LoadoutSlot_IsReady( LocalClientEHI(), emoteSlot ) )
					loadoutEntries.append( emoteSlot )
			}
			break

		case eItemType.sticker:
			for ( int stickerObjectType = 0; stickerObjectType < eStickerObjectType.len(); stickerObjectType++ )
			{
				for ( int stickerIndex = 0; stickerIndex < GetMaxStickersForObjectType( stickerObjectType ); stickerIndex++ )
				{
					LoadoutEntry stickerSlot = Loadout_Sticker( stickerObjectType, stickerIndex )
					if ( LoadoutSlot_IsReady( LocalClientEHI(), stickerSlot ) )
						loadoutEntries.append( stickerSlot )
				}
			}
			break

		

		case eItemType.character:
			
			ItemFlavor characterSkin = CharacterClass_GetDefaultSkin( item )
			loadoutEntries = [ Loadout_CharacterSkin( CharacterSkin_GetCharacterFlavor( characterSkin ) ) ]
			break


		default:
			Assert( false, "Loot Ceremony equip button does not support reward type: " + DEV_GetEnumStringSafe( "eItemType", itemType ) )
	}

	return loadoutEntries
}




LoadoutEntry function PopulateInspectMenuDetails_GetStatTrackerLoadoutEntry( ItemFlavor item, bool findExistingEntry )
{
	ItemFlavor ornull character = GladiatorCardStatTracker_GetCharacterFlavor( item )
	if ( character == null ) 
		character = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() )

	expect ItemFlavor( character )

	for ( int trackerIndex = 0; trackerIndex < GLADIATOR_CARDS_NUM_TRACKERS; trackerIndex++ )
	{
		LoadoutEntry trackerSlot = Loadout_GladiatorCardStatTracker( character, trackerIndex )
		ItemFlavor flavor        = LoadoutSlot_GetItemFlavor( LocalClientEHI(), trackerSlot )

		if ( findExistingEntry )
		{
			if ( flavor == item )
				return trackerSlot
		}
		else if ( LoadoutSlot_IsReady( LocalClientEHI(), trackerSlot ) )
		{
			if ( GladiatorCardTracker_IsTheEmpty( flavor ) )
				return trackerSlot
		}
	}

	LoadoutEntry fallback = Loadout_GladiatorCardStatTracker( character, (GLADIATOR_CARDS_NUM_TRACKERS - 1) )
	return fallback
}








































































































const float INSPECT_FORWARD_OFFSET = 136.0
const float INSPECT_FORWARD_OFFSET_WEAPON = 100.0
const float INSPECT_FORWARD_OFFSET_CHARM = 45.0
const float INSPECT_FORWARD_OFFSET_EXECUTION = 100.0
const float INSPECT_FORWARD_OFFSET_CURRENCY = 100.0

const float INSPECT_RIGHT_OFFSET = -24.0
const float INSPECT_RIGHT_OFFSET_WEAPON = -18.0
const float INSPECT_RIGHT_OFFSET_CHARM = -7.5
const float INSPECT_RIGHT_OFFSET_EXECUTION = -20.0
const float INSPECT_RIGHT_OFFSET_CURRENCY = -20.0

const float INSPECT_UP_OFFSET = 30.0
const float INSPECT_UP_OFFSET_EXECUTION = 28.0
const float INSPECT_UP_OFFSET_CHARM = 30.0
















































































































































































































































































































































































































bool function IsItemEquipped( ItemFlavor item )
{
	array<LoadoutEntry> entries = EquipButton_GetItemLoadoutEntries( item, true )
	foreach ( entry in entries )
	{
		if ( item == LoadoutSlot_GetItemFlavor( LocalClientEHI(), entry ) )
			return true
	}

	return false
}




string function GetCurrentlyEquippedItemNameForItemTypeSlot( ItemFlavor referenceItem )
{
	array<LoadoutEntry> entries = EquipButton_GetItemLoadoutEntries( referenceItem, true )

	ItemFlavor equippedItem = LoadoutSlot_GetItemFlavor( LocalClientEHI(), entries[ 0 ] )
	return ItemFlavor_GetLongName( equippedItem )
}




int function GetCurrentlyEquippedItemRarityForItemTypeSlot( ItemFlavor referenceItem )
{
	array<LoadoutEntry> entries = EquipButton_GetItemLoadoutEntries( referenceItem, true )

	ItemFlavor equippedItem = LoadoutSlot_GetItemFlavor( LocalClientEHI(), entries[ 0 ] )

	if ( ItemFlavor_HasQuality( equippedItem ) )
		return ItemFlavor_GetQuality( equippedItem )

	return -1
}
























































































































































const float EXECUTION_START_VIDEO_DELAY = 0.25
const float EXECUTION_START_TURNTABLE_DELAY = 0.15
















































































































































































































































































const float QUIP_START_AUDIO_DELAY = 0.25

















































































































































































































































































































































































































const float TURNTABLE_MAX_TURN_DEGREES = 360.0
const float TURNTABLE_MAX_PITCH_DEGREES_WEAPON = 60.0





















































































































































































void function InitLootBoxMenu( var newMenuArg )

{
	var menu = GetMenu( "LootBoxOpen" )
	fileForever.menu = menu
	fileForever.blackFlash = Hud_GetChild( fileForever.menu, "BlackFlash" )

	AddMenuEventHandler( menu, eUIEvent.MENU_OPEN, OnLootBoxMenu_Open )
	AddMenuEventHandler( menu, eUIEvent.MENU_CLOSE, OnLootBoxMenu_Close )
	AddMenuEventHandler( menu, eUIEvent.MENU_NAVIGATE_BACK, OnLootBoxMenu_NavBack )

	AddMenuFooterOption( menu, LEFT, BUTTON_B, true, "#B_BUTTON_BACK", "#B_BUTTON_BACK", null, ShouldShowBackButton )

	
	fileForever.storeButton = Hud_GetChild( menu, "StoreButton" )
	HudElem_SetRuiArg( fileForever.storeButton, "buttonText", Localize( "#STORE_MENU" ) )
	AddButtonEventHandler( fileForever.storeButton, UIE_CLICK, OnClickStoreButton )

	
	fileForever.lootBoxOpenButton = Hud_GetChild( fileForever.menu, "OpenLootBoxButton" )
	HudElem_SetRuiArg( fileForever.lootBoxOpenButton, "buttonText", Localize( "#OPEN_NEXT_LOOT" ) )
	HudElem_SetRuiArg( fileForever.lootBoxOpenButton, "descText", "" )
	AddButtonEventHandler( fileForever.lootBoxOpenButton, UIE_CLICK, LootBoxOpenAdditional )

	
	fileForever.inspectMenu = Hud_GetChild( fileForever.menu, "InspectBar" )
	HudElem_SetRuiArg( fileForever.inspectMenu, "itemType", "#UNKNOWN_LOOT_REWARD" )
	HudElem_SetRuiArg( fileForever.inspectMenu, "itemName", "#UNKNOWN_LOOT_REWARD" )
	HudElem_SetRuiArg( fileForever.inspectMenu, "reqsText", "" )

	fileForever.equipButton = Hud_GetChild( fileForever.menu, "InspectEquipButton" )
	HudElem_SetRuiArg( fileForever.equipButton, "buttonText", Localize( "#EQUIP_LOOT_REWARD" ) )
	AddButtonEventHandler( fileForever.equipButton, UIE_CLICK, EquipButtonOnClick )

	fileForever.trackChallengeButton = Hud_GetChild( fileForever.menu, "TrackChallengeButton" )
	AddButtonEventHandler( fileForever.trackChallengeButton, UIE_CLICK, TrackButtonOnClick )

	fileForever.equipToWheelButton = Hud_GetChild( fileForever.menu, "InspectEquipToWheelButton" )
	HudElem_SetRuiArg( fileForever.equipToWheelButton, "buttonText", Localize( "#EQUIP_WHEEL_LOOT_REWARD" ) )
	HudElem_SetRuiArg( fileForever.equipToWheelButton, "descText", "" )
	AddButtonEventHandler( fileForever.equipToWheelButton, UIE_CLICK, EquipToWheelButtonOnClick )

	fileForever.purchaseButton = Hud_GetChild( fileForever.menu, "InspectPurchaseButton" )
	HudElem_SetRuiArg( fileForever.purchaseButton, "buttonText", "" )
	AddButtonEventHandler( fileForever.purchaseButton, UIE_CLICK, PurchaseButtonOnClick )


		fileForever.battlePassButton = Hud_GetChild( fileForever.menu, "InspectBattlePassPurchaseButton" )
		HudElem_SetRuiArg( fileForever.battlePassButton, "buttonText", Localize( "#STORE_BATTLEPASS_UNLOCK" ) )
		HudElem_SetRuiArg( fileForever.battlePassButton, "descText", Localize( "#STORE_WITH_PREMIUM" ) )
		AddButtonEventHandler( fileForever.battlePassButton, UIE_CLICK, BattlePassButtonOnClick )


	fileForever.mouseClickElem = Hud_GetChild( fileForever.menu, "ModelRotateMouseCapture" )
	fileForever.inspectVideoPanel = Hud_GetChild( fileForever.menu, "InspectVideoPanel" )

	
	array<var> inspectRewardButtonArray
	fileForever.inspectRewardButton1 = Hud_GetChild( fileForever.menu, "RewardLeftButton" )
	inspectRewardButtonArray.append( fileForever.inspectRewardButton1 )

	fileForever.inspectRewardButton2 = Hud_GetChild( fileForever.menu, "RewardCenterButton" )
	inspectRewardButtonArray.append( fileForever.inspectRewardButton2 )

	fileForever.inspectRewardButton3 = Hud_GetChild( fileForever.menu, "RewardRightButton" )
	inspectRewardButtonArray.append( fileForever.inspectRewardButton3 )

	foreach ( var button in inspectRewardButtonArray )
	{
		AddButtonEventHandler( button, UIE_CLICK, PreviewButtonOnClick )
		AddButtonEventHandler( button, UIE_GET_FOCUS, PreviewButtonOnHover )
		AddButtonEventHandler( button, UIE_LOSE_FOCUS, PreviewButtonOnLeaveHover )
	}

	
	fileForever.skipAnimButton = Hud_GetChild( fileForever.menu, "SkipAnimationButton" )
	AddButtonEventHandler( fileForever.skipAnimButton, UIE_CLICK, SkipAnimButtonOnClick )

	AddUICallback_OnLevelInit( OnLevelInit )
}




void function LootCeremony_UpdateOpenAdditionalButton()
{
	bool showButton = false
	

	if ( HasLootBeenPresented() && !IsInspectModeActive() && !IsSpecialItemPresentationModeActive() )
	{
		if ( GRX_IsInventoryReady() )
		{
			
			showButton = true
			array<ItemFlavor> specificPackFlavs = []
			if ( fileLevel.forceParticularPackFlav != null )
				specificPackFlavs.append( expect ItemFlavor( fileLevel.forceParticularPackFlav ) )
			UpdateLootBoxButton( fileForever.lootBoxOpenButton, specificPackFlavs )
		}
	}

	Hud_SetVisible( fileForever.lootBoxOpenButton, showButton )
	
	
	if ( fileLevel.considerFocusOpenButton )
	{
		fileLevel.considerFocusOpenButton = false
		if ( showButton )
			Hud_SetFocused( fileForever.lootBoxOpenButton )
	}
}




bool function HasLootBeenPresented()
{
	return fileLevel.lootHasBeenPresented
}




void function OnLevelInit()
{
	RunClientScript( "UIToClient_LootCeremony_SetMenuHandles", fileForever.menu )
}




void function ClientToUI_SetLootHasBeenPresented( bool heirloomShards = false )
{
	fileLevel.lootHasBeenPresented = true
	fileLevel.considerFocusOpenButton = true
	fileLevel.heirloomShards = heirloomShards
	UpdateFooterOptions()

	if ( !heirloomShards )
	{
		HudElem_SetRuiArg( fileForever.storeButton, "buttonText", Localize( "#APEX_PACKS" ) )
		HudElem_SetRuiArg( fileForever.storeButton, "icon", ItemFlavor_GetIcon( GRX_CURRENCIES[GRX_CURRENCY_PREMIUM] ) )
	}
	else
	{
		HudElem_SetRuiArg( fileForever.storeButton, "buttonText", Localize( "#HEIRLOOM_SHOP" ) )
		HudElem_SetRuiArg( fileForever.storeButton, "icon", ItemFlavor_GetIcon( GRX_CURRENCIES[GRX_CURRENCY_HEIRLOOM] ) )
	}
}




void function ClientToUI_UpdateStoreButtonVisibility()
{
	bool visible = HasLootBeenPresented() && !IsInspectModeActive() && !IsSpecialItemPresentationModeActive()

	Hud_SetVisible( fileForever.storeButton, visible )
	Hud_SetEnabled( fileForever.storeButton, visible )

	entity player = GetLocalClientPlayer()
	if ( GRX_IsOfferRestricted( player ) && !fileLevel.heirloomShards )
	{
		Hud_SetEnabled( fileForever.storeButton, false )
	}
}




bool function IsInspectModeActive()
{
	return fileLevel.inspectModeActive
}




bool function IsSpecialItemPresentationModeActive()
{
	return fileLevel.specialItemPresentationModeActive
}




void function ClientToUI_SetInspectModeIsActive()
{
	fileLevel.inspectModeActive = true
}




void function ClientToUI_ClearInspectModeIsActive()
{
	fileLevel.inspectModeActive = false
}




void function SetStoreItemPresentationModeActive( GRXScriptOffer grxOffer )
{
	Assert( grxOffer.output.flavors.len() == 1 )

	fileLevel.specialItemPresentationModeActive = true
	fileLevel.storeItemPresentationModeOffer = grxOffer
	fileLevel.specialItemPresentationModeItemFlav = grxOffer.output.flavors[0]
	fileLevel.specialItemPresentationModeItemQty = grxOffer.output.quantities[0]
	fileLevel.specialItemPresentationModeItemBadgeTier = -1
	fileLevel.storeItemPresentationModeItemPrereq = grxOffer.prereq
	fileLevel.specialItemFormattedPrice = GRX_GetFormattedPrice( grxOffer.prices[0], 1 )
	fileLevel.specialItemOverrideOwned = null
	fileLevel.specialItemHideEquipButton = false
	fileLevel.specialItemHidePurchaseButton = false
	fileLevel.specialItemPriceHeader = "#CONFIRM_PURCHASE_WITH"
	fileLevel.specialItemLockPurchaseButton = false
	fileLevel.specialItemPackName = null
	fileLevel.specialItemPackImg = null
	fileLevel.specialPurchaseDialogConfig = null
	fileLevel.onNavigatingBackFunc = null

		fileLevel.isBpOwned = false
		fileLevel.isBpRewardPremium = false

	AdvanceMenu( GetMenu( "LootBoxOpen" ) )
}

void function SetBattlePassItemPresentationModeActive( BattlePassReward bpReward )
{
	fileLevel.specialItemPresentationModeActive = true
	fileLevel.storeItemPresentationModeOffer = null
	fileLevel.specialItemPresentationModeItemFlav = bpReward.flav
	fileLevel.specialItemPresentationModeItemQty = bpReward.quantity
	fileLevel.specialItemPresentationModeItemBadgeTier = (  ItemFlavor_GetQuality(bpReward.flav) > 2 && ItemFlavor_GetType( bpReward.flav ) == eItemType.gladiator_card_badge)? BATTLEPASS_MAX_LEVEL : -1 
	fileLevel.storeItemPresentationModeItemPrereq = null
	fileLevel.specialItemFormattedPrice = bpReward.isPremium ? "#BATTLE_PASS_PREMIUM_REWARD" : "#BATTLE_PASS_FREE_REWARD"
	fileLevel.specialItemOverrideOwned = null
	fileLevel.specialItemHideEquipButton = !(IsItemFlavorEquippable( bpReward.flav ))
	fileLevel.specialItemHidePurchaseButton = false
	fileLevel.specialItemPriceHeader = Localize( "#BATTLE_PASS_LEVEL_REQUIRED", bpReward.level + 1 )
	fileLevel.specialItemLockPurchaseButton = true
	fileLevel.specialItemPackName = null
	fileLevel.specialItemPackImg = null
	fileLevel.specialPurchaseDialogConfig = null
	fileLevel.onNavigatingBackFunc = null


		ItemFlavor ornull activeBattlePass = GetPlayerLastActiveBattlePass( ToEHI( GetLocalClientPlayer() ) )
		bool hasActiveBattlePass = activeBattlePass != null && GRX_IsInventoryReady()
		if ( hasActiveBattlePass )
		{
			expect ItemFlavor( activeBattlePass )
			fileLevel.isBpOwned = DoesPlayerOwnBattlePass( GetLocalClientPlayer(), activeBattlePass )
		}

		fileLevel.isBpRewardPremium = bpReward.isPremium

	AdvanceMenu( GetMenu( "LootBoxOpen" ) )
}

void function SetTreasurePackItemPresentationModeActive( BattlePassReward bpReward )
{
	fileLevel.specialItemPresentationModeActive = true
	fileLevel.storeItemPresentationModeOffer = null
	fileLevel.specialItemPresentationModeItemFlav = bpReward.flav
	fileLevel.specialItemPresentationModeItemQty = bpReward.quantity
	fileLevel.specialItemPresentationModeItemBadgeTier = -1
	fileLevel.storeItemPresentationModeItemPrereq = null
	fileLevel.specialItemFormattedPrice = bpReward.isPremium ? "#BATTLE_PASS_PREMIUM_REWARD" : "#BATTLE_PASS_FREE_REWARD"
	fileLevel.specialItemOverrideOwned = null
	fileLevel.specialItemHideEquipButton = !(IsItemFlavorEquippable( bpReward.flav ))
	fileLevel.specialItemHidePurchaseButton = true
	fileLevel.specialItemPriceHeader = Localize( "#BATTLE_PASS_LEVEL_REQUIRED", bpReward.level + 1 )
	fileLevel.specialItemLockPurchaseButton = true
	fileLevel.specialItemPackName = null
	fileLevel.specialItemPackImg = null
	fileLevel.specialPurchaseDialogConfig = null
	fileLevel.onNavigatingBackFunc = null

		fileLevel.isBpOwned = false
		fileLevel.isBpRewardPremium = false


	AdvanceMenu( GetMenu( "LootBoxOpen" ) )
}

void function SetGenericItemPresentationModeActiveWithNavBack( ItemFlavor itemFlav, string priceHeader, string subHeader, void functionref() onNavigatingBackFunc )
{
	fileLevel.specialItemPresentationModeActive = true
	fileLevel.storeItemPresentationModeOffer = null
	fileLevel.specialItemPresentationModeItemFlav = itemFlav
	fileLevel.specialItemPresentationModeItemQty = 1
	fileLevel.specialItemPresentationModeItemBadgeTier = -1
	fileLevel.storeItemPresentationModeItemPrereq = null
	fileLevel.specialItemFormattedPrice = subHeader
	fileLevel.specialItemOverrideOwned = null
	fileLevel.specialItemHideEquipButton = false
	fileLevel.specialItemHidePurchaseButton = false
	fileLevel.specialItemPriceHeader = priceHeader
	fileLevel.specialItemLockPurchaseButton = true
	fileLevel.specialItemPackName = null
	fileLevel.specialItemPackImg = null
	fileLevel.specialPurchaseDialogConfig = null
	fileLevel.onNavigatingBackFunc = onNavigatingBackFunc

		fileLevel.isBpOwned = false
		fileLevel.isBpRewardPremium = false


	AdvanceMenu( GetMenu( "LootBoxOpen" ) )
}

void function SetCollectionEventItemPresentationModeActive( ItemFlavor flav, GRXScriptOffer ornull grxOffer, string ornull packName, asset ornull packImg )
{
	string priceText = ""
	if ( grxOffer != null )
	{
		expect GRXScriptOffer(grxOffer)
		array<string> formattedPrices
		foreach ( ItemFlavorBag price in grxOffer.prices )
			formattedPrices.append( GRX_GetFormattedPrice( price, 1 ) )

		if ( formattedPrices.len() == 1 )
			priceText = Localize( "#STORE_PRICE_N", formattedPrices[0] )
		else if ( formattedPrices.len() == 2 )
			priceText = Localize( "#STORE_PRICE_N_N", formattedPrices[0], formattedPrices[1] )
	}

	fileLevel.specialItemPresentationModeActive = true
	fileLevel.storeItemPresentationModeOffer = grxOffer
	fileLevel.specialItemPresentationModeItemFlav = flav
	fileLevel.specialItemPresentationModeItemQty = 1
	fileLevel.specialItemPresentationModeItemBadgeTier = -1
	fileLevel.storeItemPresentationModeItemPrereq = null
	fileLevel.specialItemFormattedPrice = priceText
	fileLevel.specialItemOverrideOwned = null
	fileLevel.specialItemHideEquipButton = false
	fileLevel.specialItemHidePurchaseButton = (grxOffer == null)
	fileLevel.specialItemPriceHeader = "#PURCHASE"
	fileLevel.specialItemLockPurchaseButton = (grxOffer == null)
	fileLevel.specialItemPackName = packName
	fileLevel.specialItemPackImg = packImg
	fileLevel.specialPurchaseDialogConfig = null
	fileLevel.onNavigatingBackFunc = null

		fileLevel.isBpOwned = false
		fileLevel.isBpRewardPremium = false


	AdvanceMenu( GetMenu( "LootBoxOpen" ) )
}

void function SetChallengeRewardPresentationModeActive( ItemFlavor itemFlav, int itemQty, int badgeDataInteger, string priceHeader, string subHeader, bool isComplete, bool specialItemHidePurchaseButton = false )
{
	fileLevel.specialItemPresentationModeActive = true
	fileLevel.storeItemPresentationModeOffer = null
	fileLevel.specialItemPresentationModeItemFlav = itemFlav
	fileLevel.specialItemPresentationModeItemQty = itemQty
	fileLevel.specialItemPresentationModeItemBadgeTier = badgeDataInteger
	fileLevel.storeItemPresentationModeItemPrereq = null
	fileLevel.specialItemOverrideOwned = isComplete
	fileLevel.specialItemHideEquipButton = !(IsItemFlavorEquippable( itemFlav ))
	fileLevel.specialItemHidePurchaseButton = specialItemHidePurchaseButton
	fileLevel.specialItemLockPurchaseButton = true
	fileLevel.specialItemPackName = null
	fileLevel.specialItemPackImg = null
	fileLevel.specialPurchaseDialogConfig = null
	fileLevel.onNavigatingBackFunc = null

		fileLevel.isBpOwned = false
		fileLevel.isBpRewardPremium = false


	if( Mythics_IsItemFlavorMythicSkin( itemFlav ) )
	{
		fileLevel.specialItemPriceHeader = "#EQUIP_LOCKED"
		fileLevel.specialItemFormattedPrice = "#CHALLENGE_MYTHIC_LOCKED_ICON"
	}
	else
	{
		fileLevel.specialItemPriceHeader = priceHeader
		fileLevel.specialItemFormattedPrice = subHeader
	}

	AdvanceMenu( GetMenu( "LootBoxOpen" ) )
}





bool function InspectItemTypePresentationSupported( ItemFlavor item )
{
	switch ( ItemFlavor_GetType( item ) )
	{
		case eItemType.account_currency_bundle:
		case eItemType.account_pack:

		

		case eItemType.character:


		case eItemType.character_skin:
		case eItemType.character_execution:
		case eItemType.weapon_skin:
		case eItemType.weapon_charm:
		case eItemType.melee_skin:
		case eItemType.gladiator_card_stance:
		case eItemType.gladiator_card_frame:
		case eItemType.gladiator_card_intro_quip:
		case eItemType.gladiator_card_kill_quip:
		case eItemType.gladiator_card_stat_tracker:
		case eItemType.gladiator_card_badge:
		case eItemType.music_pack:
		case eItemType.loadscreen:
		case eItemType.skydive_emote:
		case eItemType.emote_icon:
		case eItemType.character_emote:
		case eItemType.sticker:
			return true

		case eItemType.account_currency:
			return ItemFlavor_GetAsset( item ) != $"settings/itemflav/grx_currency/crafting.rpak" 

		case eItemType.voucher:
			return Voucher_GetModel( item ) != $""
	}

	return false
}
























void function OnLobbyOpenLootBoxMenu_ButtonPress( ItemFlavor ornull forceParticularPackFlav = null )
{
	fileLevel.forceParticularPackFlav = forceParticularPackFlav
	AdvanceMenu( GetMenu( "LootBoxOpen" ) )
}




void function OnLootBoxMenu_Open()
{
	UI_SetPresentationType( ePresentationType.INACTIVE )
	Lobby_AdjustScreenFrameToMaxSize( Hud_GetChild( fileForever.menu, "ScreenFrame" ), true )

	thread LootCeremonyFlashScreenBlack_Internal()

	HudElem_SetRuiArg( fileForever.inspectMenu, "moveDescDown", false )
	HudElem_SetRuiArg( fileForever.inspectMenu, "showPackDetails", false )
	HudElem_SetRuiArg( fileForever.inspectMenu, "packName", "" )
	HudElem_SetRuiArg( fileForever.inspectMenu, "packImg", $"", eRuiArgType.IMAGE )

	if ( IsSpecialItemPresentationModeActive() )
	{
		AddCallbackAndCallNow_OnGRXInventoryStateChanged( UpdateSpecialItemPresentationPurchaseButton )
		AddCallbackAndCallNow_OnGRXOffersRefreshed( UpdateSpecialItemPresentationPurchaseButton )

		SpecialItemPresentationSequenceUI()
		LootCeremony_UpdateOpenAdditionalButton()
	}
	else
	{
		Hud_SetVisible( fileForever.purchaseButton, false )
		Hud_SetEnabled( fileForever.purchaseButton, false )


			Hud_SetVisible( fileForever.battlePassButton, false )
			Hud_SetEnabled( fileForever.battlePassButton, false )


		AddCallbackAndCallNow_OnGRXInventoryStateChanged( LootCeremony_UpdateOpenAdditionalButton )
		thread LootBoxOpenSequenceUI( true )
	}
}




void function OnLootBoxMenu_Close()
{
	fileLevel.forceParticularPackFlav = null
	if ( IsSpecialItemPresentationModeActive() )
	{
		fileLevel.specialItemPresentationModeActive = false
		RunClientScript( "UIToClient_SpecialItemPresentationExit" )

		RemoveCallback_OnGRXInventoryStateChanged( UpdateSpecialItemPresentationPurchaseButton )
		RemoveCallback_OnGRXOffersRefreshed( UpdateSpecialItemPresentationPurchaseButton )

		fileLevel.specialItemPresentationModeActive = false
		fileLevel.storeItemPresentationModeOffer = null
		
		fileLevel.specialItemPresentationModeItemQty = -1
		fileLevel.specialItemPresentationModeItemBadgeTier = -1
		fileLevel.storeItemPresentationModeItemPrereq = null
		fileLevel.specialItemFormattedPrice = ""
		fileLevel.specialItemOverrideOwned = null
		fileLevel.specialItemHideEquipButton = false
		fileLevel.specialItemHidePurchaseButton = false
		fileLevel.specialItemPriceHeader = ""
		fileLevel.specialItemLockPurchaseButton = false
		fileLevel.onNavigatingBackFunc = null

			fileLevel.isBpOwned = false
			fileLevel.isBpRewardPremium = false

	}
	else
	{
		RunClientScript( "UIToClient_LootCeremonyExit" )
		RemoveCallback_OnGRXInventoryStateChanged( LootCeremony_UpdateOpenAdditionalButton )
		Remote_ServerCallFunction( "Server_GrantLegendaryStickersIfCollectionCompleted" )
	}
}




bool function ShouldShowBackButton()
{
	if ( IsSpecialItemPresentationModeActive() )
		return true

	return HasLootBeenPresented()
}




void function OnClickStoreButton( var button )
{
	if ( fileLevel.heirloomShards )
		JumpToHeirloomShop()
	else
		JumpToStorePacks()
}




void function OnLootBoxMenu_NavBack()
{
	if ( !HasLootBeenPresented() && !IsSpecialItemPresentationModeActive() )
		return

	if ( IsInspectModeActive() && !IsSpecialItemPresentationModeActive() )
	{
		RunClientScript( "UIToClient_RewardInspectNavBack" )
		return
	}

	if ( IsSpecialItemPresentationModeActive() && (fileLevel.onNavigatingBackFunc != null) )
		fileLevel.onNavigatingBackFunc()

	CloseActiveMenu()
}




void function LootBoxOpenAdditional( var button )
{
	thread LootBoxOpenSequenceUI( false )
}




void function EquipButtonOnClick( var button )
{
	RunClientScript( "UIToClient_RewardEquipOnClick" )
}

void function TrackButtonOnClick( var button )
{
	RunClientScript( "UIToClient_TrackButtonOnClick" )
}

void function ClientToUI_EquipButtonShowDialog( SettingsAssetGUID itemGUID )
{
	ItemFlavor item             = GetItemFlavorByGUID( itemGUID )
	array<LoadoutEntry> entries = EquipButton_GetItemLoadoutEntries( item )

	
	OpenSelectSlotDialog( entries, item, GetItemFlavorAssociatedCharacterOrWeapon( item ),
		(void function( int index ) : ()
		{
			RunClientScript( "UIToClient_RewardEquipOnClickWithIndex", index )
		})
	)
}


void function ClientToUI_TrackMythicChallenge( SettingsAssetGUID skinGUID )
{
	SettingsAssetGUID challengeGUID = Mythics_GetChallengeGUIDForSkinGUID( skinGUID )
	ItemFlavor challenge = GetItemFlavorByGUID( challengeGUID )
	Mythics_ToggleTrackChallenge( challenge, fileForever.trackChallengeButton )
}


void function EquipToWheelButtonOnClick( var button )
{
	RunClientScript( "UIToClient_RewardEquipToWheelOnClick" )
}

void function ClientToUI_EquipToWheelButtonShowDialog( SettingsAssetGUID itemGUID )
{
	ItemFlavor item             = GetItemFlavorByGUID( itemGUID )
	int itemType                = ItemFlavor_GetType( item )
	
	ItemFlavor character        = expect ItemFlavor( GetItemFlavorAssociatedCharacterOrWeapon( item ) )
	array<LoadoutEntry> entries = []
	int numSlots
	LoadoutEntry functionref( ItemFlavor, int ) getEntryFunc

	
	

	if ( itemType == eItemType.skydive_emote )
	{
		numSlots     = NUM_SKYDIVE_EMOTE_SLOTS
		getEntryFunc = Loadout_SkydiveEmote
	}
	else
	{
		numSlots     = MAX_QUIPS_EQUIPPED
		getEntryFunc = Loadout_CharacterQuip
	}

	for ( int i = 0; i < numSlots; i++ )
	{
		LoadoutEntry entry = getEntryFunc( character, i )
		if ( LoadoutSlot_IsReady( LocalClientEHI(), entry ) )
			entries.append( entry )
	}

	
	OpenSelectSlotDialog( entries, item, character,
		(void function( int index ) : ()
		{
			RunClientScript( "UIToClient_RewardEquipToWheelOnClickWithIndex", index )
		})
	)
}




void function PurchaseButtonOnClick( var button )
{
	if ( fileLevel.storeItemPresentationModeItemPrereq != null )
	{
		ItemFlavor prereqFlav = expect ItemFlavor( fileLevel.storeItemPresentationModeItemPrereq )
		if ( !GRX_IsItemOwnedByPlayer_AllowOutOfDateData( prereqFlav, null ) )
		{
			ConfirmDialogData dialogData
			dialogData.headerText = "#STORE_REQUIREMENTS_FAILED"
			dialogData.messageText = Localize( "#STORE_REQUIRES_LOCKED", Localize( ItemFlavor_GetLongName( prereqFlav ) ) )
			dialogData.contextImage = $"ui/menu/common/dialog_notice"

			OpenOKDialogFromData( dialogData )

			HudElem_SetRuiArg( fileForever.purchaseButton, "descText", Localize( "#STORE_REQUIRES_LOCKED", Localize( ItemFlavor_GetLongName( prereqFlav ) ) ) )
			return
		}
	}

	if ( fileLevel.specialPurchaseDialogConfig != null )
	{
		PurchaseDialog( expect PurchaseDialogConfig( fileLevel.specialPurchaseDialogConfig ) )
	}
	else if ( fileLevel.storeItemPresentationModeOffer != null )
	{
		PurchaseDialogConfig pdc
		pdc.offer = fileLevel.storeItemPresentationModeOffer
		PurchaseDialog( pdc )
	}
	else
	{
		PurchaseDialogConfig pdc
		pdc.flav = fileLevel.specialItemPresentationModeItemFlav
		PurchaseDialog( pdc )
	}
}




void function BattlePassButtonOnClick( var button )
{
	CloseActiveMenu()
	BattlePass_PurchaseButton_OnActivate( button )
}




void function PreviewButtonOnClick( var button )
{
	if ( !IsFullyConnected() )
		return

	RunClientScript( "UIToClient_RewardInspectActivate", button )
}




void function PreviewButtonOnHover( var button )
{
	if ( !IsFullyConnected() )
		return

	RunClientScript( "UIToClient_RewardPlacard_Hover", button, true )
}




void function PreviewButtonOnLeaveHover( var button )
{
	if ( !IsFullyConnected() )
		return

	RunClientScript( "UIToClient_RewardPlacard_Hover", button, false )
}




void function LootBoxOpenSequenceUI( bool firstTime )
{
	fileLevel.lootHasBeenPresented = false
	UpdateFooterOptions()
	Hud_SetVisible( fileForever.storeButton, false )
	Hud_SetEnabled( fileForever.storeButton, false )

	
	ItemFlavor ornull pack
	if ( fileLevel.forceParticularPackFlav )
	{
		pack = fileLevel.forceParticularPackFlav
	}
	else
	{
		pack = GetNextLootBox()
	}
	Assert( pack != null )
	expect ItemFlavor( pack )
	int quality = ItemFlavor_GetQuality( pack )

	RunClientScript( "UIToClient_LootCeremony_SetMenuHandles", fileForever.menu )

	if ( firstTime )
	{
		RunClientScript( "UIToClient_EnterLootCeremony", ItemFlavor_GetGUID( pack ) )
	}
	else
	{
		RunClientScript( "UIToClient_AdditionalLootTick_Sequence", ItemFlavor_GetGUID( pack ) )
	}

	ScriptGRXOperationInfo operation
	operation.expectedQueryGoal = GRX_HTTPQUERYGOAL_OPEN_PACK
	operation.doOperationFunc = (void function( int opID ) : ( pack ) {
		printt( "GRX_OpenPack", opID, ItemFlavor_GetGRXIndex( pack ) )
		GRX_OpenPack( opID, ItemFlavor_GetGRXIndex( pack ) )
	})
	operation.onDoneCallback = (void function( int status ) : ( operation ) {
		if ( status == eScriptGRXOperationStatus.DONE_SUCCESS )
			RunClientScript( "UIToClient_OnGRXPackOpeningResultsAvailable" )
		else
			CloseActiveMenu()
	})
	QueueGRXOperation( GetLocalClientPlayer(), operation )
}




void function SpecialItemPresentationSequenceUI()
{
	UpdateFooterOptions()
	Hud_SetVisible( fileForever.storeButton, false )
	Hud_SetEnabled( fileForever.storeButton, false )

	RunClientScript( "UIToClient_LootCeremony_SetMenuHandles", fileForever.menu )
	RunClientScript( "UIToClient_SpecialItemPresentation", ItemFlavor_GetGUID( fileLevel.specialItemPresentationModeItemFlav ), fileLevel.specialItemPresentationModeItemQty, fileLevel.specialItemPresentationModeItemBadgeTier )
	

	UpdateSpecialItemPresentationPurchaseButton()
}

void function ClientToUI_UpdateSpecialItemPresentationPurchaseButton()
{
	UpdateSpecialItemPresentationPurchaseButton()
}




void function UpdateSpecialItemPresentationPurchaseButton()
{
	if ( !IsSpecialItemPresentationModeActive() )
		return

	HudElem_SetRuiArg( fileForever.purchaseButton, "buttonText", fileLevel.specialItemPriceHeader )
	HudElem_SetRuiArg( fileForever.purchaseButton, "descText", fileLevel.specialItemFormattedPrice )

	bool isOfferUnavailable = false
	if ( fileLevel.storeItemPresentationModeOffer != null && !(expect GRXScriptOffer(fileLevel.storeItemPresentationModeOffer)).isAvailable )
	{
		isOfferUnavailable = true
		HudElem_SetRuiArg( fileForever.purchaseButton, "buttonText", "#UNAVAILABLE" )
		string unavailableReason = (expect GRXScriptOffer(fileLevel.storeItemPresentationModeOffer)).unavailableReason
		HudElem_SetRuiArg( fileForever.purchaseButton, "descText", unavailableReason != "#UNAVAILABLE" ? unavailableReason : "" )
	}
	else if ( fileLevel.storeItemPresentationModeItemPrereq != null )
	{
		ItemFlavor prereqFlav = expect ItemFlavor( fileLevel.storeItemPresentationModeItemPrereq )
		if ( !GRX_IsItemOwnedByPlayer_AllowOutOfDateData( prereqFlav, null ) )
			HudElem_SetRuiArg( fileForever.purchaseButton, "descText", Localize( "#STORE_REQUIRES_LOCKED", Localize( ItemFlavor_GetLongName( prereqFlav ) ) ) )
	}

	ItemFlavor itemFlav = fileLevel.specialItemPresentationModeItemFlav
	int itemType = ItemFlavor_GetType( itemFlav )

	bool showPurchase = false
	bool showEquip    = false
	bool isOwned      = false

	if ( GRX_IsInventoryReady() )
	{
		if ( fileLevel.specialItemOverrideOwned != null )
			isOwned = expect bool(fileLevel.specialItemOverrideOwned)
		else if ( itemType == eItemType.gladiator_card_badge )
			isOwned = GladiatorCardBadge_DoesStatSatisfyValue( itemFlav, float(fileLevel.specialItemPresentationModeItemBadgeTier) )
		else if ( ItemFlavor_GetGRXMode( itemFlav ) == eItemFlavorGRXMode.REGULAR )
			isOwned = GRX_IsItemOwnedByPlayer( itemFlav, null )

		if ( IsItemFlavorTypeEquippable( itemFlav ) )
		{
			if ( !fileLevel.specialItemHidePurchaseButton )
				showPurchase = !isOwned

			if ( !fileLevel.specialItemHideEquipButton )
				showEquip = isOwned
		}
		
		
		
		
		else if ( fileLevel.storeItemPresentationModeOffer != null )
		{
			showPurchase = !GRXOffer_IsFullyClaimed( expect GRXScriptOffer(fileLevel.storeItemPresentationModeOffer) )
		}
	}

	Hud_SetVisible( fileForever.purchaseButton, showPurchase )
	Hud_SetEnabled( fileForever.purchaseButton, !fileLevel.specialItemLockPurchaseButton && !isOfferUnavailable )
	Hud_SetLocked( fileForever.purchaseButton, fileLevel.specialItemLockPurchaseButton || isOfferUnavailable )

	Hud_SetVisible( fileForever.equipButton, showEquip )
	Hud_SetEnabled( fileForever.equipButton, true )
	Hud_SetLocked( fileForever.equipButton, false )


		Hud_SetVisible( fileForever.battlePassButton, !fileLevel.isBpOwned && fileLevel.isBpRewardPremium )
		Hud_SetEnabled( fileForever.battlePassButton, !fileLevel.isBpOwned && fileLevel.isBpRewardPremium )


	if ( showPurchase || showEquip )
	{
		HudElem_SetRuiArg( fileForever.inspectMenu, "moveDescDown", true )
	}

	if ( fileLevel.specialItemPackName != null && showPurchase )
	{
		HudElem_SetRuiArg( fileForever.inspectMenu, "showPackDetails", true )
		HudElem_SetRuiArg( fileForever.inspectMenu, "packName", expect string(fileLevel.specialItemPackName) )
		HudElem_SetRuiArg( fileForever.inspectMenu, "packImg", expect asset(fileLevel.specialItemPackImg), eRuiArgType.IMAGE )
	}
	else
	{
		HudElem_SetRuiArg( fileForever.inspectMenu, "showPackDetails", false )
	}

	bool showUnlockedWithoutEquip = isOwned && ( itemType == eItemType.gladiator_card_badge ||
											  itemType == eItemType.sticker ||
											  itemType == eItemType.weapon_charm ||
										      itemType == eItemType.music_pack )

	if ( showUnlockedWithoutEquip )
	{
		Hud_SetVisible( fileForever.equipButton, true )
		Hud_SetEnabled( fileForever.equipButton, false )
		Hud_SetLocked( fileForever.equipButton, true )

		HudElem_SetRuiArg( fileForever.equipButton, "buttonText", "#UNLOCKED" )

		string descText = ""
		if ( itemType == eItemType.gladiator_card_badge )
			descText = "#EQUIP_IN_LEGENDS_MENU"
		else if ( itemType == eItemType.weapon_charm || itemType == eItemType.music_pack || itemType == eItemType.sticker )
			descText = "#EQUIP_IN_LOADOUT_MENU"

		HudElem_SetRuiArg( fileForever.equipButton, "descText", descText )
	}
}


const float BLACK_FADE_TIME = 0.25
const float BLACK_FADE_TIME_HOLD = 0.25



void function LootCeremonyFlashScreenBlack_Internal()
{
	Hud_SetAlpha( fileForever.blackFlash, 255 )
	Hud_Show( fileForever.blackFlash )
	wait BLACK_FADE_TIME_HOLD
	Hud_FadeOverTime( fileForever.blackFlash, 0, BLACK_FADE_TIME, INTERPOLATOR_ACCEL )
	wait BLACK_FADE_TIME
	Hud_Hide( fileForever.blackFlash )
}




void function ClientToUI_PlayLootCeremonySound( string alias )
{
	EmitUISound( alias )
}




void function ClientToUI_StopLootCeremonySound( string alias )
{
	StopUISoundByName( alias )
}




void function SkipAnimButtonOnClick( var button )
{
	RunClientScript( "UIToClient_SkipAnimation" )
}




void function ClientToUI_LootCeremonyMarkItemAsNoLongerNew( SettingsAssetGUID itemFlavorGUID )
{
	ItemFlavor item = GetItemFlavorByGUID( itemFlavorGUID )
	Newness_IfNecessaryMarkItemFlavorAsNoLongerNewAndInformServer( item )
}























ItemFlavor ornull function GetNextLootBox()
{
	ItemFlavor ornull nextPack = null

	table<ItemFlavor, int> packCountMap = GRX_GetPackCounts()

	int highestQuality = 0
	foreach ( ItemFlavor pack, int count in packCountMap )
	{
		asset packIcon = GRXPack_GetOpenButtonIcon( pack )
		int quality    = ItemFlavor_GetQuality( pack )
		if ( count == 0 || quality < highestQuality || ( quality == highestQuality && packIcon == "" ) )
			continue

		highestQuality = quality
		nextPack = pack
	}

	return nextPack

}

void function ForceOpenRewardPacks()
{
	foreach ( basePack in GRX_GetStickerPacksWithRewards() )
	{
		ItemFlavor rewardPack = GetItemFlavorByAsset( GRXPack_GetStickerCompletionRewardPack( basePack ) )
		printt( "*** starting force open thread for base pack guid: " + basePack.guid )
		thread TryForceOpenRewardPackThread( rewardPack )
	}
}

void function TryForceOpenRewardPackThread( ItemFlavor pack )
{
	bool grxReady = GRX_IsInventoryReady() && GRX_AreOffersReady()
	if ( !grxReady )
	{
		WaitFrame()
		printt( "*** waiting a frame for GRX to report ready" )
	}

	int packCount = GRX_GetPackCount( ItemFlavor_GetGRXIndex( pack ) )
	if ( packCount > 0 )
	{
		printt( "*** force opening reward pack for guid: " + pack.guid )
		OnLobbyOpenLootBoxMenu_ButtonPress( pack )
	}
	else
	{
		printt( "*** we didn't have a pack to open with guid: " + pack.guid )
	}
}







































































