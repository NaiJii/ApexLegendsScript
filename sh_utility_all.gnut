untyped

globalize_all_functions

global const float FLOAT_INFINITY = 3.40282e+38 + 3.40282e+38
global const float FLOAT_INDETERMINATE = FLOAT_INFINITY * 0.0
global const float FLOAT_NAN = -FLOAT_INDETERMINATE

global const float DEG_TO_RAD = 0.01745329251994 
global const float RAD_TO_DEG = 57.29577951308232 

global const float DOT_1DEGREE =	0.9998476951564
global const float DOT_2DEGREE =	0.9993908270191
global const float DOT_3DEGREE =	0.9986295347546
global const float DOT_4DEGREE =	0.9975640502598
global const float DOT_5DEGREE =	0.9961946980917
global const float DOT_6DEGREE =	0.9945218953683
global const float DOT_7DEGREE =	0.9925461516413
global const float DOT_8DEGREE =	0.9902680687416
global const float DOT_9DEGREE =	0.9876883405951
global const float DOT_10DEGREE =	0.9848077530122
global const float DOT_15DEGREE =	0.9659258262891
global const float DOT_20DEGREE =	0.9396926207859
global const float DOT_25DEGREE =	0.9063077870367
global const float DOT_30DEGREE =	0.866025403784
global const float DOT_45DEGREE =	0.707106781187
global const float DOT_50DEGREE =	0.64278760968
global const float DOT_60DEGREE =	0.5
global const float DOT_80DEGREE =	0.17364817766
global const float DOT_85DEGREE =	0.0871557427477

global const string WHITESPACE_CHARACTERS = "\r\n\t " 







#if DEV
global enum eAssetType
{
	ASSETTYPE_CHARACTER,
	ASSETTYPE_WEAPON,
	ASSETTYPE_CHARM,

	_count
}
#endif


global const PST_TIME_ZONE_OFFSET = -8        
global const PDT_TIME_ZONE_OFFSET = -7
global enum eDaysOfWeek
{
	SUNDAY,
	MONDAY,
	TUESDAY,
	WEDNESDAY,
	THURSDAY,
	FRIDAY,
	SATURDAY,
	_NUM_DAYS
}
global const array<string> MONTH_NAMES = [
	"#MONTH_JAN",
	"#MONTH_FEB",
	"#MONTH_MAR",
	"#MONTH_APR",
	"#MONTH_MAY",
	"#MONTH_JUN",
	"#MONTH_JUL",
	"#MONTH_AUG",
	"#MONTH_SEP",
	"#MONTH_OCT",
	"#MONTH_NOV",
	"#MONTH_DEC",
]
global struct TimeParts
{
	int year
	int month
	int day
	int hour
	int minute
	int second
}
global struct DisplayTime
{
	int days
	int hours
	int minutes
	int seconds
}

global struct Coord
{
	vector pos
	vector ang
}

global struct AABB
{
	vector mins
	vector maxs
}

global struct PassByReferenceInt
{
	int value
}

global struct PassByReferenceFloat
{
	float value
}

global struct PassByReferenceBool
{
	bool value
}

global struct PassByReferenceVector
{
	vector value
}

global struct PassByReferenceEntity
{
	entity value
}

global enum eStreamMode
{
	DISABLED,
	KILLER,
	ALL,
}

global struct Timeout
{
	float startTime
	float duration
}

global struct ShuffleData
{
	array<int> _indices
	int        _pos
}

global struct DebounceData
{
	float              lastRunTime = 0.0
	bool               isQueued = false
	void functionref() latestFunc
}

const int THROTTLE_DEFAULT_MAXPERINTERVAL = 1
const float THROTTLE_DEFAULT_INTERVAL = 1.0
global struct ThrottleData
{
	float lastProcessTime = 0.0
	float decayingActionCount = 0
	float interval = THROTTLE_DEFAULT_INTERVAL
	int   maxPerInterval = THROTTLE_DEFAULT_MAXPERINTERVAL
}

global struct WaitQuotaItem
{
	int _count
	int _budget
}

struct
{
	int  lastHostThreadMode
	int  lastScriptPrecacheErrors
	int  lastReportFatal
	bool devUnlockedSPMissions

	int hud_setting_accessibleChatCache
} file

void function ShUtilityAll_Init()
{
	#document( "DistanceAlongVector", "" )
	#document( "GetClosestPointOnLineSegment", "Get the nearest point on a line segment" )
	#document( "GetDistanceFromLineSegment", "" )
	#document( "GetDistanceSqrFromLineSegment", "" )

	RegisterSignal( "Timeout" )
	RegisterSignal( "CancelTimeout" )

















}


Timeout function BeginTimeout( float duration )
{
	Timeout to

	to.startTime = UITime()



	to.duration = duration
	thread __RunTimeoutInternal( to )
	return to
}


void function __RunTimeoutInternal( Timeout to )
{
	EndSignal( to, "CancelTimeout" )
	wait to.duration
	Signal( to, "Timeout" )
}


void function CancelTimeoutIfAlive( Timeout to )
{
	Signal( to, "CancelTimeout" )
}





void function PrintObject( obj, int indent, int depth, int maxDepth )
{
	if ( IsTable( obj ) )
	{
		if ( depth >= maxDepth )
		{
			printl( "{...}" )
			return
		}

		printl( "{" )
		foreach ( k, v in obj )
		{
			print( TableIndent( indent + 2 ) + k + " = " )
			PrintObject( v, indent + 2, depth + 1, maxDepth )
		}
		printl( TableIndent( indent ) + "}" )
	}
	else if ( IsArray( obj ) )
	{
		if ( depth >= maxDepth )
		{
			printl( "[...]" )
			return
		}

		printl( "[" )
		foreach ( v in obj )
		{
			print( TableIndent( indent + 2 ) )
			PrintObject( v, indent + 2, depth + 1, maxDepth )
		}
		printl( TableIndent( indent ) + "]" )
	}
	else if ( obj != null )
	{
		printl( "" + obj )
	}
	else
	{
		printl( "<null>" )
	}
}


string function GetStack( int offset = 2 )
{
	string stackInfo = ""

	for ( int i = offset; i < 20; i++ )
	{
		if ( !("src" in getstackinfos( i )) )
			break

		if ( i != offset )
		{
			stackInfo += "\n"
		}

		stackInfo += getstackinfos( i )["src"] + " [" + getstackinfos( i )["line"] + "], " + getstackinfos( i )["func"] + "()"
	}

	return stackInfo
}

string function GetPreviousFunction()
{
	int i = 3
	if ( !("src" in getstackinfos( i )) )
		return ""
	return "Called from: " + getstackinfos( i )["src"] + " [" + getstackinfos( i )["line"] + "] : " + getstackinfos( i )["func"] + "() "
}


bool function IsNewThread()
{
	int i
	for ( i = 0 ; i < 20; i++ )
	{
		if ( !("src" in getstackinfos( i )) )
			break
	}

	return (i == 3)
}


bool function CallingFuncIsNewThread()
{
	int i
	for ( i = 0 ; i < 20; i++ )
	{
		if ( !("src" in getstackinfos( i )) )
			break
	}

	const int CHECK_DEPTH = 4
	return (i == CHECK_DEPTH)
}


void function AssertIsNewThread()
{
	Assert( CallingFuncIsNewThread(), "Must be threaded" )
}


void function AssertParameters( func, int paramCount, string paramDesc )
{
	table funcInfos = expect table( func.getinfos() )
	string funcName = expect string( funcInfos.name )
	
	Assert( funcInfos.parameters.len() == (paramCount + 1), "Function \"" + funcName + "\" must have exactly " + paramCount + " parameters (" + paramDesc + ")." )
}


string function GetNameForEnum( table<string, int> enumTable, int val )
{
	foreach ( string name, int index in enumTable )
	{
		if ( index == val )
			return name
	}
	return format( "%s() - INVALID: %d", FUNC_NAME(), val )
}


void function PrintTable( tbl, int indent = 0, int maxDepth = 4 )
{
	print( TableIndent( indent ) )
	PrintObject( tbl, indent, 0, maxDepth )
}


string function TableIndent( int indent )
{
	return ("                                            ").slice( 0, indent )
}


string function RepeatString( string str, int times )
{
	string out = ""
	for ( int i = 0; i < times; i++ )
	{
		out += str
	}
	return out
}


bool function IsOdd( int num )
{
	return (num % 2) == 1
}


bool function IsEven( int num )
{
	return !IsOdd( num )
}


float function DegToRad( float degrees )
{
	return degrees * DEG_TO_RAD
}


float function RadToDeg( float radians )
{
	return radians * RAD_TO_DEG
}


float function CalcFOVScale( float baseFOV, float zoomScale )
{
	return RadToDeg( atan( tan( DegToRad( baseFOV / 2.0 ) ) / zoomScale ) ) * 2
}

int function CalcZoomMag( float baseFOV, float fov )
{
	float magf = tan( DegToRad( baseFOV/2 ) ) / tan( DegToRad( fov/2 ) )
	return int ( floor( magf + 0.5) )
}


vector function RotateAroundOrigin2D( vector originToRotate, vector origin, float angRadians )
{
	vector rotated     = <0, 0, originToRotate.z>
	float sinOffsetAng = sin( angRadians )
	float cosOffsetAng = cos( angRadians )
	vector offset      = originToRotate - origin

	rotated.x = origin.x + (offset.x * cosOffsetAng) - (offset.y * sinOffsetAng)
	rotated.y = origin.y + (offset.x * sinOffsetAng) + (offset.y * cosOffsetAng)

	return rotated
}


vector function RotateVector( vector vec, vector rotateAngles )
{
	return vec.x * AnglesToForward( rotateAngles ) + vec.y * -1.0 * AnglesToRight( rotateAngles ) + vec.z * AnglesToUp( rotateAngles )

	
	
	
	
}


AABB function RotateAABB( vector mins, vector maxs, vector rotateAngles )
{
	vector cnr_000 = RotateVector( < mins.x, mins.y, mins.z >, rotateAngles )
	vector cnr_001 = RotateVector( < mins.x, mins.y, maxs.z >, rotateAngles )
	vector cnr_010 = RotateVector( < mins.x, maxs.y, mins.z >, rotateAngles )
	vector cnr_011 = RotateVector( < mins.x, maxs.y, maxs.z >, rotateAngles )
	vector cnr_100 = RotateVector( < maxs.x, mins.y, mins.z >, rotateAngles )
	vector cnr_101 = RotateVector( < maxs.x, mins.y, maxs.z >, rotateAngles )
	vector cnr_110 = RotateVector( < maxs.x, maxs.y, mins.z >, rotateAngles )
	vector cnr_111 = RotateVector( < maxs.x, maxs.y, maxs.z >, rotateAngles )

	AABB result
	result.mins = <
	min( cnr_000.x, min( cnr_001.x, min( cnr_010.x, min( cnr_011.x, min( cnr_100.x, min( cnr_101.x, min( cnr_110.x, cnr_111.x ) ) ) ) ) ) ),
	min( cnr_000.y, min( cnr_001.y, min( cnr_010.y, min( cnr_011.y, min( cnr_100.y, min( cnr_101.y, min( cnr_110.y, cnr_111.y ) ) ) ) ) ) ),
	min( cnr_000.z, min( cnr_001.z, min( cnr_010.z, min( cnr_011.z, min( cnr_100.z, min( cnr_101.z, min( cnr_110.z, cnr_111.z ) ) ) ) ) ) )
	>
	result.maxs = <
	max( cnr_000.x, max( cnr_001.x, max( cnr_010.x, max( cnr_011.x, max( cnr_100.x, max( cnr_101.x, max( cnr_110.x, cnr_111.x ) ) ) ) ) ) ),
	max( cnr_000.y, max( cnr_001.y, max( cnr_010.y, max( cnr_011.y, max( cnr_100.y, max( cnr_101.y, max( cnr_110.y, cnr_111.y ) ) ) ) ) ) ),
	max( cnr_000.z, max( cnr_001.z, max( cnr_010.z, max( cnr_011.z, max( cnr_100.z, max( cnr_101.z, max( cnr_110.z, cnr_111.z ) ) ) ) ) ) )
	>
	return result
}


float function RadWrap( float ang, float lowValue = -PI )
{
	return ((ang - lowValue) % (2.0 * PI)) + lowValue
}


vector function FindAnyPerpendicularVector( vector v )
{
	return RotateVector( <0, 0, 1> * Length( v ), VectorToAngles( Normalize( v ) ) )
}


float function GetArcLengthDeg( float startDeg, float endDeg )
{
	if ( endDeg < startDeg )
		endDeg += 360

	return fabs( startDeg - endDeg )
}

bool function CirclesAreIntersecting( vector org1, float rad1, vector org2, float rad2 )
{
	float distBetweenCircles = Distance( org1, org2 )
	float epsilon = 1

	
	if ( distBetweenCircles < fabs( rad1 - rad2 ) + epsilon )
		return false
	else if ( distBetweenCircles < fabs( rad2 - rad1 ) + epsilon )
		return false

	
	else if ( distBetweenCircles == 0 && rad2 == rad1 )
		return false

	
	else if ( distBetweenCircles > ( rad1 + rad2 + epsilon ) )
		return false

	return true
}

bool function IsCircleAEncompassingCircleB( vector org1, float rad1, vector org2, float rad2 )
{
	float epsilon
	float distBetweenCircles = Distance( org1, org2 )
	if ( ( distBetweenCircles < fabs( rad1 - rad2 ) + epsilon ) && ( rad1 > rad2 ) )
		return true

	return false
}

array<vector> function GetCircleToCircleIntersectionPoints( vector org1, float rad1, vector org2, float rad2, vector up = < 0, 0, 1 >, bool debugDraw = false )
{
	float distBetweenCircles        = Distance( org1, org2 )
	float distOrg1ToIntersectCenter = ( ( rad1 * rad1 ) - ( rad2 * rad2 ) + ( distBetweenCircles * distBetweenCircles ) ) / ( 2.0 * distBetweenCircles )

	vector intersectDir    = Normalize( org2 - org1 )
	vector intersectCenter = intersectDir * distOrg1ToIntersectCenter

	float intersectHeight = sqrt( ( rad1 * rad1 ) - ( distOrg1ToIntersectCenter * distOrg1ToIntersectCenter ) )
	vector heightDir      = CrossProduct( up, intersectDir )

	array<vector> intersectionPoints = [ intersectCenter + ( heightDir * intersectHeight ), intersectCenter - ( heightDir * intersectHeight ) ]

	if ( debugDraw )
	{









	}

	return intersectionPoints
}

bool function IsLobbyMapName( string levelname )
{
	if ( levelname == "mp_lobby" )
		return true

	return false
}

bool function IsStormPoint()
{
	string mapName

		mapName = GetActiveLevel()



	return mapName == "mp_rr_tropic_island"
}

bool function Freelance_IsHubLevel()
{
#if 0

		string mapName = GetActiveLevel()




	switch( mapName )
	{
		case "mp_rr_nobody":
			return true
	}
#endif
	return false
}


bool function IsOrientationMatch()
{
	return GetCurrentPlaylistName() == PLAYLIST_NEW_PLAYER_ORIENTATION
}



bool function Is2TeamPvPGame()

{
	return (MAX_TEAMS == 2)
}


bool function IsMultiTeamPvPGame()
{
	return (MAX_TEAMS > 2)
}


bool function IsFFAGame()
{
	return (MAX_TEAMS == MAX_PLAYERS)
}


bool function IsSingleTeamMode()
{
	return (1 == GetCurrentPlaylistVarInt( "max_teams", 2 ))
}


bool function IsMultiTeamMission()
{
	if ( IsSingleTeamMode() )
		return false
	if ( Freelance_IsHubLevel() )
		return false
	return true
}


bool function IsShotgunsAndSnipersMode()
{
	return GetCurrentPlaylistVarBool( "shotguns_and_snipers_mode", false )
}


bool function IsArmedAndDangerousEvolvedMode()
{
	return GetCurrentPlaylistName() == "armed_and_dangerous_evolved"
}


int function GetExpectedSquadSize( entity player = null )
{
	
	return int ( GetCurrentPlaylistVarFloat( "max_players", 60 ) / GetCurrentPlaylistVarFloat( "max_teams", 20 ) )
}


bool function IsDuoMode()
{
	return (GetCurrentPlaylistVarFloat( "max_players", 60 ) / GetCurrentPlaylistVarFloat( "max_teams", 20 ) == 2.0)
}


bool function IsSoloMode()
{
	return GetCurrentPlaylistVarBool( "solo_mode", false )
}


bool function IsLastPlaylistSolo( entity player )
{
	return GetPersistentLastGameTypeFlag( player, eGameType.SOLO )
}


bool function IsS03E03Mode()
{
	return GetCurrentPlaylistVarBool( "s03e03_mode", false )
}


bool function IsThirdPersonMode()
{
	return GetCurrentPlaylistVarBool( "thirdperson_mode", false )
}


bool function IsSpawnOnSquadMode()
{
	return GetCurrentPlaylistVarBool( "spawn_on_squad_mode", false )
}

bool function IsShadowRoyaleMode()
{
	return GetCurrentPlaylistVarBool( "shadow_royale_mode", false )
}

bool function IsPVEMode()
{

		{
			string playlistName = GetCurrentPlaylistName()
			if ( playlistName.find( "freelance" ) == 0 )
				return true

			return false
		}







}


bool function IsNightMapMode()
{
	return GetCurrentPlaylistVarBool( "night_map_mode", false )
}


bool function IsAlwaysBeClosingMode()
{
	return GetCurrentPlaylistVarBool( "always_be_closing_mode", false )
}


bool function IsGoldRushMode()
{
	return GetCurrentPlaylistVarBool( "gold_rush_mode", false )
}


bool function IsDummieMode()
{
	return GetCurrentPlaylistVarBool( "dummie_mode", false )
}

bool function IsRingCollapseGameMode()
{
	return GetCurrentPlaylistVarBool( "is_ring_collapse", false )
}

bool function IsFinishTheFightGameMode()
{
	return GetCurrentPlaylistVarBool( "is_finish_the_fight", false )
}

bool function IsACETakeOverGameMode()
{
	return GetCurrentPlaylistVarBool( "is_ace_takeover", false )
}

bool function IsAprilFools_S8_Mode()
{
	return GetCurrentPlaylistVarBool( "is_april_fools_s8", false )
}

bool function HasBoundaryWall()
{
	return GetCurrentPlaylistVarBool( "has_boundary_wall", false )
}

bool function Control_IsModeEnabled()
{
	return GetCurrentPlaylistVarBool( "is_control_game", false )
}


bool function TDM_IsModeEnabled()
{
	return GetCurrentPlaylistVarBool( "freedm_tdm_active", false)
}










bool function GunGame_IsModeEnabled()
{
	return GetCurrentPlaylistVarBool( "freedm_gun_game_active", false)
}


bool function UseLTMPodiumBanner()
{
	return ( GetCurrentPlaylistVarString( "gamemode_logo", "BATTLE_ROYALE" ) == "LTM" )
}




















bool function WinterExpress_IsModeEnabled()
{
	return GetCurrentPlaylistVarBool( "is_winter_express_game", false )
}


bool function PrestigeBadgeIsAllowed()
{
	bool allowBadges    = GetCurrentPlaylistVarBool( "allow_prestige_badges", false )
	string playlistName = GetCurrentPlaylistName()
	string funcName     = FUNC_NAME()
















	printf( "%s(): playlist = %s - deferring to allow_prestige_badges = %s", funcName, playlistName, allowBadges ? "True" : "False" )
	return allowBadges
}

bool function IsSpectator( entity player )
{
	if ( !IsValid( player ) )
		return false

	return player.GetTeam() == TEAM_SPECTATOR
}


int function GetEnemyTeam( int team )
{
	if ( IsMultiTeamPvPGame() )
		return TEAM_UNASSIGNED

	if ( team == TEAM_SPECTATOR )
		return TEAM_UNASSIGNED

	Assert( team == TEAM_IMC || team == TEAM_MILITIA )

	return (TEAM_IMC + TEAM_MILITIA) - team
}


array<int> function GetAllEnemyTeams( int team )
{
	array<int> resultArray
	if ( Is2TeamPvPGame() || IsSingleTeamMode() )
	{
		resultArray.append( GetEnemyTeam( team ) )
		return resultArray
	}

	int maxTeams = GetCurrentPlaylistVarInt( "max_teams", MAX_TEAMS )
	Assert( team >= TEAM_MULTITEAM_FIRST )
	Assert( team <= TEAM_MULTITEAM_LAST )

	for ( int i = TEAM_MULTITEAM_FIRST; i < TEAM_MULTITEAM_FIRST + maxTeams; ++i )
	{
		if ( i == team )
			continue

		resultArray.append( i )
	}

	return resultArray
}


array<int> function GetAllTeams()
{
	array<int> resultArray

	int maxTeams = GetCurrentPlaylistVarInt( "max_teams", MAX_TEAMS )

	for ( int i = TEAM_MULTITEAM_FIRST; i < TEAM_MULTITEAM_FIRST + maxTeams; ++i )
	{
		resultArray.append( i )
	}

	return resultArray
}


bool function IsPositionWithinRadius( float radius, vector position1, vector position2 )
{
	float radiusToTestSqr = pow( radius, 2 )
	float positionDistSqr = Distance2DSqr( position1, position2 )

	if ( positionDistSqr < radiusToTestSqr )
		return true

	return false
}

int function GetDefaultNonSpectatorTeam()
{
	int resultTeam

	if ( Is2TeamPvPGame() )
		resultTeam = TEAM_IMC
	else
		resultTeam = TEAM_MULTITEAM_FIRST

	return resultTeam
}


string function GetMapDisplayNameAllCaps( string mapname )
{
	return "#" + mapname + "_ALLCAPS"
}


string function GetMapDisplayName( string mapname )
{
	return "#" + mapname
}


string function GetMapDisplayDesc( string mapname )
{
	return "#" + mapname + "_CLASSIC_DESC"
}


float function RoundToNearestInt( float value )
{
	return floor( value + 0.5 )
}


float function RoundToNearestMultiplier( float value, float multiplier )
{
	Assert( multiplier > 0 )
	bool neg = value < 0
	value = fabs( value )

	float remainder = value % multiplier

	value -= remainder

	if ( remainder >= (multiplier / 2) )
		value += multiplier

	return neg ? -value : value
}

bool function IsBitFlagSet( int bitMask, int flag )
{
	return ( bitMask & flag ) != 0
}

int function HIWORD( int value )
{
	return (value >> 16) & 0xFFFF
}


int function LOWORD( int value )
{
	return value
}


bool function IsWeaponKeyFieldDefined( string ref, string variable )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )

	if ( val != null )
		return true

	return false
}


string function GetWeaponInfoFileKeyField_GlobalString( string ref, string variable )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	return expect string( val )
}

string function GetWeaponInfoFileKeyField_WithMods_GlobalString( string ref, array<string> mods, string variable )
{
	var val = GetWeaponInfoFileKeyField_WithMods_Global( ref, mods, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	return expect string( val )
}

int function GetWeaponInfoFileKeyField_GlobalInt( string ref, string variable )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	return expect int( val )
}

int function GetWeaponInfoFileKeyField_WithMods_GlobalInt( string ref, array<string> mods, string variable )
{
	var val = GetWeaponInfoFileKeyField_WithMods_Global( ref, mods, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	return expect int( val )
}

int function GetWeaponInfoFileKeyField_GlobalInt_WithDefault( string ref, string variable, int defaultVal )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )
	return val != null ? expect int( val ) : defaultVal
}


float function GetWeaponInfoFileKeyField_GlobalFloat( string ref, string variable )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	return expect float( val )
}


bool function GetWeaponInfoFileKeyField_GlobalBool( string ref, string variable )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	return expect bool( val )
}

vector function GetWeaponInfoFileKeyField_GlobalVectorFloat( string ref, string variable, string delimiter = WHITESPACE_CHARACTERS )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	expect string( val )
	array<string> arr = split( val, delimiter )
	Assert( arr.len() >= 3, "Vector value \"" + val + " has < 3 arguments" )
	return <float(arr[0]), float(arr[1]), float(arr[2])>
}

vector function GetWeaponInfoFileKeyField_GlobalVectorInt( string ref, string variable, string delimiter = WHITESPACE_CHARACTERS )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	expect string( val )
	array<string> arr = split( val, delimiter )
	Assert( arr.len() >= 3, "Vector value \"" + val + " has < 3 arguments" )
	return <int(arr[0]), int(arr[1]), int(arr[2])>
}






































































void function WaitFrame()
{
	
	wait 0.0001
}


void function WaitFrames( int frames )
{
	int framesRemaining = frames
	while ( framesRemaining > 0 )
	{
		WaitFrame()
		framesRemaining--
	}
}












string function VectorToString( vector vec )
{
	return "< " + vec.x + "," + vec.y + "," + vec.z + " >"
}

string function VectorToColorString( vector color, float alpha )
{
	return color.x + " " + color.y + " " + color.z + " " + alpha
}

vector function FlattenNormalizeVec( vector v )
{
	return Normalize( <v.x, v.y, 0> )
}

bool function VectorWithinBounds( vector v, float maxValue )
{
	return (fabs( v.x ) < maxValue && fabs( v.y ) < maxValue && fabs( v.z ) < maxValue)
}



int function GetReportStyle()
{





		return GetCurrentPlaylistVarInt( "enable_report", 2 )

}


vector function GetClosestPointOnPlane( vector a, vector b, vector c, vector p, bool clampInside = false )
{
	vector n    = CrossProduct( b - a, c - a )
	float eqTop = DotProduct( p - a, n )
	float eqBot = DotProduct( n, n )

	
	if ( fabs( eqBot ) < 0.001 )
		return GetClosestPointOnLineSegment( a, b, p )

	float magnitude = eqTop / eqBot

	vector endPoint = p - (n * magnitude)

	if ( clampInside )
	{
		float testAB = DotProduct( CrossProduct( b - a, n ), p - a )
		float testBC = DotProduct( CrossProduct( c - b, n ), p - b )
		float testCA = DotProduct( CrossProduct( a - c, n ), p - c )

		
		if ( testAB * testBC < 0 || testBC * testCA < 0 )
		{
			vector lineAB = GetClosestPointOnLineSegment( a, b, p )
			vector lineBC = GetClosestPointOnLineSegment( b, c, p )
			vector lineCA = GetClosestPointOnLineSegment( c, a, p )

			vector closestVector = lineAB
			float closestDist    = DistanceSqr( p, lineAB )
			float dist           = DistanceSqr( p, lineBC )
			if ( dist < closestDist )
			{
				closestDist = dist
				closestVector = lineBC
			}
			dist = DistanceSqr( p, lineCA )
			if ( dist < closestDist )
			{
				closestDist = dist
				closestVector = lineCA
			}
			return closestVector
		}
		
	}

	return endPoint
}


float function DistanceAlongVector( vector origin, vector lineStart, vector lineForward )
{
	vector originDif = origin - lineStart
	return DotProduct( originDif, lineForward )
}


vector function GetClosestPointOnLineSegment( vector a, vector b, vector p )
{
	float distanceSqr = LengthSqr( a - b )

	if ( distanceSqr == 0.0 )
		return a

	float t = DotProduct( p - a, b - a ) / distanceSqr
	if ( t < 0.0 )
		return a
	else if ( t > 1.0 )
		return b

	return a + t * (b - a)
}


vector function GetClosestPointOnLine( vector a, vector b, vector p )
{
	float distanceSqr = LengthSqr( a - b )

	if ( distanceSqr == 0.0 )
		return a

	float t = DotProduct( p - a, b - a ) / distanceSqr

	return a + t * (b - a)
}


vector ornull function GetIntersectionOfLineAndPlane( vector a, vector b, vector planePoint, vector planeNormal )
{
	float sT = DotProduct( planeNormal, planePoint - a )
	float sB = DotProduct( planeNormal, b - a )

	if ( sB > -0.0000001 && sB < 0.0000001 )
		return null

	float s = sT / sB
	return a + (b - a) * s
}


float function GetDistanceFromLineSegment( vector a, vector b, vector p )
{
	vector closestPoint = GetClosestPointOnLineSegment( a, b, p )
	return Distance( p, closestPoint )
}


float function GetDistanceSqrFromLineSegment( vector a, vector b, vector p )
{
	vector closestPoint = GetClosestPointOnLineSegment( a, b, p )
	return DistanceSqr( p, closestPoint )
}


float function GetProgressAlongLineSegment( vector P, vector A, vector B )
{
	vector AP = P - A
	vector AB = B - A

	float ab2   = DotProduct( AB, AB ) 
	float ap_ab = DotProduct( AP, AB ) 
	float t     = ap_ab / ab2
	return t
}


string function PadString( string str, int len )
{
	for ( int i = str.len(); i < len; i++ )
		str += " "

	return str
}


bool function IsSpawner( entity ent )
{
	return (IsValid( ent ) && ent.GetNetworkedClassName() == "spawner")
}


string function GetAISettingsStringForMode()
{
	return "aiSettingsFile"
}




float function EaseIn( float val )
{
	return AttackDecay( 0, 2, val )
}


float function EaseOut( float val )
{
	return AttackDecay( 2, 0, val )
}


float function AttackDecay( float attack, float decay, float time )
{
	float sum = attack + decay
	float a   = sum - 2.0
	float b   = (3.0 - attack) - sum
	float c   = attack
	float t   = max( min( time, 1.0 ), 0.0 )

	return t * (c + t * (b + t * a))
}


float function Clamp( float value, float minValue, float maxValue )
{
	return max( min( value, maxValue ), minValue )
}


int function ClampInt( int value, int minValue, int maxValue )
{
	return maxint( minint( value, maxValue ), minValue )
}



void function RemoveDupesFromSorted_String( array<string> data )
{
	for ( int i = 0; i < data.len() - 1; i++ )
	{
		if ( data[i] == data[i + 1] )
		{
			data.remove( i )
			i--
		}
	}
}


function SortAlphabetize( a, b )
{
	if ( a > b )
		return 1

	if ( a < b )
		return -1

	return 0
}


int function SortStringAlphabetize( string a, string b )
{
	if ( a > b )
		return 1

	if ( a < b )
		return -1

	return 0
}


int function SortAssetAlphabetize( asset a, asset b )
{
	if ( a > b )
		return 1

	if ( a < b )
		return -1

	return 0
}


void function RemoveDupesFromSorted_Asset( array<asset> data )
{
	for ( int i = 0; i < data.len() - 1; i++ )
	{
		if ( data[i] == data[i + 1] )
		{
			data.remove( i )
			i--
		}
	}
}


void function DisablePrecacheErrors()
{
	file.lastHostThreadMode = GetConVarInt( "host_thread_mode" )
	file.lastScriptPrecacheErrors = GetConVarInt( "script_precache_errors" )
	file.lastReportFatal = GetConVarInt( "fs_report_sync_opens_fatal" )









		ClientCommand( "host_thread_mode 0" )
		ClientCommand( "script_precache_errors 0" )
		ClientCommand( "fs_report_sync_opens_fatal 0" )

}

void function RestorePrecacheErrors()
{








		ClientCommand( "host_thread_mode " + file.lastHostThreadMode )
		ClientCommand( "script_precache_errors " + file.lastScriptPrecacheErrors )
		ClientCommand( "fs_report_sync_opens_fatal " + file.lastReportFatal )

}




















string function GetTitanReadyHintFromSetFile( asset setFile )
{
	return GetGlobalSettingsString( setFile, "readyhint" )
}


bool function CoinFlip()
{
	return RandomInt( 2 ) != 0
}


ToolTipData function CreateSimpleToolTip( string titleText, string descText, string actionHint1 = "", string actionHint2 = "", string actionHint3 = "", string actionHint4 = "" )
{
	ToolTipData toolTipData
	toolTipData.titleText = titleText
	toolTipData.descText = descText
	toolTipData.actionHint1 = actionHint1
	toolTipData.actionHint2 = actionHint2
	toolTipData.actionHint3 = actionHint3
	toolTipData.actionHint4 = actionHint4

	return toolTipData
}




bool function PointInBounds( vector point, UIPos pos, UISize size )
{
	if ( point.x < pos.x )
		return false
	if ( point.y < pos.y )
		return false
	if ( point.x > pos.x + size.width )
		return false
	if ( point.y > pos.y + size.height )
		return false

	return true
}





UIPos function REPLACEHud_GetPos( var panel )
{
	var untypedPos = Hud_GetPos( panel )

	UIPos pos
	pos.x = expect int( untypedPos[0] )
	pos.y = expect int( untypedPos[1] )

	return pos
}


UIPos function REPLACEHud_GetAbsPos( var panel )
{
	var untypedPos = Hud_GetAbsPos( panel )

	UIPos pos
	pos.x = expect int( untypedPos[0] )
	pos.y = expect int( untypedPos[1] )

	return pos
}


UIPos function REPLACEHud_GetBasePos( var panel )
{
	var untypedPos = Hud_GetBasePos( panel )

	UIPos pos
	pos.x = expect int( untypedPos[0] )
	pos.y = expect int( untypedPos[1] )

	return pos
}


UISize function REPLACEHud_GetSize( var panel )
{
	var untypedSize = Hud_GetSize( panel )

	UISize size
	size.width = expect int( untypedSize[0] )
	size.height = expect int( untypedSize[1] )

	return size
}

UIPos function REPLACEHud_GetParentRelativePos( var panel )
{
	var untypedPos = Hud_GetParentRelativePos( panel )

	UIPos pos
	pos.x = expect int( untypedPos[0] )
	pos.y = expect int( untypedPos[1] )

	return pos
}

UISize function GetScreenSize()
{

		return REPLACEHud_GetSize( GetMenu( "MainMenu" ) )









}

UIScaleFactor function GetContentScaleFactor( var panel )
{
	UISize size
	float heightBasis = 1080.0


		size = REPLACEHud_GetSize( panel )






	float aspectRatio = size.width / float( size.height )

	UIScaleFactor scaleFactor
	scaleFactor.x = size.width / (heightBasis * aspectRatio)
	scaleFactor.y = size.height / heightBasis

	return scaleFactor
}

UIScaleFactor function GetContentFixedScaleFactor( var panel )
{
	UISize size
	float vwidth  = 1920
	float vheight = 1080


		size = REPLACEHud_GetSize( panel )






	float rx = size.width / vwidth
	float ry = size.height / vheight

	UIScaleFactor scaleFactor
	if ( rx < ry )
	{
		scaleFactor.x = rx
		scaleFactor.y = rx
	}
	else
	{
		scaleFactor.x = ry
		scaleFactor.y = ry
	}

	return scaleFactor
}

bool function ButtonIsBoundToAction( int buttonID, string actionSubString )
{
	string binding = GetEffectiveButtonBinding( buttonID )
	if ( binding.tolower().find_olduntyped( actionSubString.tolower() ) != null )
		return true

	return false
}

bool function ButtonIsBoundToHoldAction( int buttonID, string actionSubString )
{
	string binding = GetEffectiveButtonHoldBinding( buttonID )
	if ( binding.tolower().find_olduntyped( actionSubString.tolower() ) != null )
		return true

	return false
}

bool function ButtonIsBoundToPing( int buttonID )
{
	return ButtonIsBoundToAction( buttonID, "+ping" )
}
























string function BackslashToSlash( string originalString )
{
	array<string> tokens = split( originalString, "\\" )
	if ( tokens.len() == 0 )
		return ""

	string resultString = tokens[0]
	for ( int index = 1; index < tokens.len(); index++ )
	{
		resultString += "/"
		resultString += tokens[index]
	}

	return resultString
}


array<string> function GetTrimmedSplitString( string originalString, string splitChars )
{
	array<string> stringList = split( originalString, splitChars )
	for ( int i = 0 ; i < stringList.len() ; i++ )
		stringList[i] = strip( stringList[i] )
	return stringList
}


array<string> function GetTrimmedSplitLoweredString( string originalString, string splitChars )
{
	array<string> stringList = split( originalString, splitChars )
	for ( int i = 0 ; i < stringList.len() ; i++ )
		stringList[i] = strip( stringList[i] ).tolower()
	return stringList
}


int function SortByEntIndex( entity a, entity b )
{
	
	if ( a.GetEntIndex() > b.GetEntIndex() )
		return 1
	else if ( a.GetEntIndex() < b.GetEntIndex() )
		return -1

	return 0
}


int function SortByTeamMemberIndex( entity a, entity b )
{
	if ( a.GetTeamMemberIndex() > b.GetTeamMemberIndex() )
		return 1
	else if ( a.GetTeamMemberIndex() < b.GetTeamMemberIndex() )
		return -1

	return 0
}

















vector function GetRandomCenterBiasedToEdge( vector center, float minDeviation, float maxDeviation, float minAngle = 0, float maxAngle = 360 )
{
	float deviation = RandomFloatRange( 0.0, 1.0 )
	deviation = minDeviation + (sqrt( deviation ) * (maxDeviation - minDeviation))
	vector angles    = <0, RandomFloatRange( minAngle, maxAngle ) % 360, 0>
	vector newCenter = center + (AnglesToForward( angles ) * deviation)
	return newCenter
}


vector function GetRandomCenter( vector center, float minDeviation, float maxDeviation, float minAngle = 0, float maxAngle = 360, var randomSeed = null )
{
	float deviation
	vector angles
	if ( IsValid ( randomSeed ) )
	{
		deviation = RandomFloatRangeSeeded( randomSeed, minDeviation, maxDeviation )
		angles = <0, RandomFloatRangeSeeded( randomSeed, minAngle, maxAngle ) % 360, 0>
	}
	else
	{
		deviation = RandomFloatRange( minDeviation, maxDeviation )
		angles = <0, RandomFloatRange( minAngle, maxAngle ) % 360, 0>
	}
	vector newCenter = center + (AnglesToForward( angles ) * deviation)
	return newCenter
}


vector function GetRandomCenterDistributed( vector center, float minDeviation, float maxDeviation, float minAngle = 0, float maxAngle = 360 )
{
	float deviation   = RandomFloatRange( minDeviation, maxDeviation )
	float angles      = RandomFloatRange( minAngle, maxAngle ) % 360
	float scale_ratio = 0
	if ( maxDeviation > 0 )	
		scale_ratio = maxDeviation / sqrt( maxDeviation )
	float r           = sqrt( deviation ) * scale_ratio
	return center + (< deg_cos( angles ) * r, deg_sin( angles ) * r, 0 >)
}

table<string, table<int, string> > reverseEnumLookupMap = {}
bool function BuildEnumReverseLookup( string enumName, bool assertOnDuplicates = true )
{
	table enumTableCopy = expect table(getconsttable()[enumName])

	table<int, string> reverseLookup = {}
	foreach ( string key, int value in enumTableCopy )
	{
		if ( value in reverseLookup )
		{
			Assert( !assertOnDuplicates, "Enum '" + enumName + "' has two keys with value '" + string(value) + "'" )
			return false
		}
		reverseLookup[value] <- key
	}
	reverseEnumLookupMap[enumName] <- reverseLookup
	return true
}


bool function IsValidEnumValue( string enumName, int value )
{
	if ( !(enumName in reverseEnumLookupMap) )
		BuildEnumReverseLookup( enumName )

	return (value in reverseEnumLookupMap[enumName])
}


string function GetEnumString( string enumName, int value )
{
	

	if ( !(enumName in reverseEnumLookupMap) )
		BuildEnumReverseLookup( enumName )

	return reverseEnumLookupMap[enumName][value]
}


string function DEV_GetEnumStringSafe( string enumName, int value )
{
	if ( IsValidEnumValue( enumName, value ) )
		return GetEnumString( enumName, value )

	return "<UNKNOWN ENUM VALUE FOR '" + enumName + "': " + value + ">"
}


string function GetEnumStringSlow( table enumTbl, int value )
{
	foreach ( entryKey, entryValue in enumTbl )
	{
		if ( entryValue == value )
			return expect string(entryKey)
	}

	return "<UNKNOWN ENUM VALUE: " + value + ">"
}


#if DEV
string function DEV_ArrayConcat( array<string> arr, string sep = "," )
{
	string out   = ""
	bool isFirst = true
	foreach ( string part in arr )
	{
		if ( isFirst )
			isFirst = false
		else
			out += sep

		out += part
	}
	return out
}
#endif


int function SortByInventoryIndexAndCount( ConsumableInventoryItem a, ConsumableInventoryItem b )
{
	if ( a.type < b.type )
		return -1
	if ( a.type > b.type )
		return 1

	if ( a.count > b.count )
		return -1
	if ( a.count < b.count )
		return 1

	return 0
}


vector function RandomVec( float range )
{
	
	vector vec = <0, 0, 0>
	vec.x = RandomFloatRange( -range, range )
	vec.y = RandomFloatRange( -range, range )
	vec.z = RandomFloatRange( -range, range )

	return vec
}


float function real_float_modulo( float x, float n )
{
	return ((x % n) + n) % n
}


int function real_int_modulo( int x, int n )
{
	return ((x % n) + n) % n
}


















void function Shuffle_Init( ShuffleData sd, int count )
{
	Assert( count > 0 )
	sd._indices.resize( count )
	for ( int idx = 0; idx < count; ++idx )
		sd._indices[idx] = idx

	sd._pos = count
}


int function Shuffle_GetNextIndex( ShuffleData sd )
{
	Assert( sd._indices.len() > 0 )

	array<int> idxs = sd._indices
	int count       = idxs.len()
	if ( count == 1 )
		return idxs[0]

	++(sd._pos)
	if ( sd._pos >= count )
	{
		int lastIndexPlayed = ((sd._pos == count) ? idxs.top() : -1)
		idxs.randomize()
		if ( idxs[0] == lastIndexPlayed )
			idxs.reverse()    

		sd._pos = 0
	}

	return idxs[sd._pos]
}


int function Shuffle_GetCount( ShuffleData sd )
{
	return sd._indices.len()
}























































void function WaitForever()
{






		WaitSignal( uiGlobal.signalDummy, "forever" )

}

bool function IsDeathDynastyEventActive()
{
	if ( CalEvent_IsActive( GetItemFlavorByAsset( $"settings/itemflav/calevent/s18ce01/collection.rpak" ), GetUnixTimestamp() ) )
		return true

	return false
}

bool function IsSurvivalTraining()
{
	return GetCurrentPlaylistVarBool( "survival_training", false )
}

bool function IsFiringRangeGameMode()
{
	return GetCurrentPlaylistVarBool( "survival_firingrange", false )
}

bool function IsTraining()
{
	return( GetCurrentPlaylistVarBool( "survival_training", false ))
}

bool function IsEventFinale()
{
	return GetCurrentPlaylistVarBool( "is_event_finale", false )
}

bool function FiringRangeHasFriendlyFire()
{
	return GetCurrentPlaylistVarBool( "firingrange_has_friendlyfire", true )
}


bool function FiringRangeHasInfiniteClips()
{
	return GetCurrentPlaylistVarBool( "has_infinite_clips", false )
}

bool function FiringRangeHasHitIndictators()
{
	return GetCurrentPlaylistVarBool ( "hud_training_hit_dots", true )
}



bool function FiringRangeHasDynamicStats()
{
	return GetCurrentPlaylistVarBool ("has_fr_dynamic_stats", true )
}


bool function FreelanceSystemsAreEnabled()
{
	const bool ENABLED_BY_DEFAULT = false
	return GetCurrentPlaylistVarBool( "freelance_systems_enabled", ENABLED_BY_DEFAULT )
}

bool function SpectreShacksAreEnabled()
{
	return GetCurrentPlaylistVarBool( "spectre_shacks_enabled", true )
}









float function LerpFloat( float startValue, float endValue, float time )
{
	return ((1 - time) * startValue + time * endValue)
}


string function RandomHex( int length = 16 )
{
	string out = ""
	for ( int idx = 0; idx < length; idx++ )
	{
		int c = RandomInt( 16 )
		out += format( "%c", (c < 10 ? '0' : ('A' - 10)) + c )
	}
	return out
}


int function StringHash( string str )
{
	int res    = 0
	int length = str.len()
	for ( int i = 0; i < length; i++ )
	{
		res *= 31
		res += expect int( str[i] )
	}
	return res
}




int function SortByScriptId( var a, var b )
{
	int aId = int( Hud_GetScriptID( a ) )
	int bId = int( Hud_GetScriptID( b ) )
	if ( aId > bId )
		return 1
	else if ( bId > aId )
		return -1

	return 0
}


bool function IsNormalized( vector vec )

{
	return fabs( 1.0 - LengthSqr( vec ) ) < 0.01
}










bool function IsAccessibilityChatHintEnabled()
{




		return GetConVarInt( "hud_setting_accessibleChat" ) == 1 || GetConVarInt( "hud_setting_accessibleChat" ) == 3

}




bool function IsAccessibilityChatToSpeech()
{
	if ( !IsAccessibilityAvailable() )
		return false

	return GetConVarInt( "speechtotext_enabled" ) > 0
}



bool function IsAccessibilityAvailable()
{

		if ( GetLanguage() != "english" )
			return false


	return true
}




int function GetStreamerMode()
{
	return GetConVarInt( "hud_setting_streamerMode" )
}




bool function DisplayKillerName()
{
	return GetStreamerMode() < eStreamMode.KILLER
}




bool function DisplayObituaryName()
{
	return GetStreamerMode() < eStreamMode.ALL
}



bool function DisplayHopupPopup()
{
	bool forceHidePopup = GetCurrentPlaylistVarBool( "hud_hide_hopuppopup", false )
	return !forceHidePopup && GetConVarBool( "hud_setting_showHopUpPopUp" )
}



bool function IsNetGraphEnabled()
{
	return GetConVarInt( "net_netGraph2" ) > 0
}



bool function IsAnonymousModeEnabled()
{
	return GetConVarInt( "hud_setting_anonymousMode" ) > 0
}



vector function GetKeyColor( int colorID, int optionalParam = 0 )
{
	Assert( optionalParam >= 0, "optionalParam must not be negative" )
	return ColorPalette_GetColorFromID( colorID + optionalParam )
}




bool function IsAccessibilityNarrationEnabled()
{
	if ( !IsAccessibilityAvailable() )
		return false

	return GetConVarInt( "hud_setting_accessibleChat" ) == 2 || GetConVarInt( "hud_setting_accessibleChat" ) == 3
}



void function Debounce( DebounceData data, float interval, void functionref() func )
{
	data.latestFunc = func

	if ( data.isQueued )
		return

	thread __DebounceInternalThread( data, interval )
}


void function __DebounceInternalThread( DebounceData data, float interval )
{
	OnThreadEnd( void function() : ( data ) {
		data.isQueued = false
		data.latestFunc = null
	} )

	data.isQueued = true


	wait max( 0.01, interval - (UITime() - data.lastRunTime) )
	data.lastRunTime = UITime()




	data.latestFunc()
}


ThrottleData function InitThrottle( float interval = THROTTLE_DEFAULT_INTERVAL, int maxPerInterval = THROTTLE_DEFAULT_MAXPERINTERVAL )
{
	ThrottleData data
	data.interval = interval
	data.maxPerInterval = maxPerInterval

	return data
}


bool function Throttle( ThrottleData data )
{

	float timeSinceLastAction = UITime() - data.lastProcessTime
	data.lastProcessTime = UITime()





	data.decayingActionCount = max( 0.0, data.decayingActionCount - timeSinceLastAction / (data.interval / data.maxPerInterval) )
	if ( data.decayingActionCount > data.interval )
		return true

	data.decayingActionCount += 1.0
	return false
}



const float GAMMA = 2.4
vector function LinearToSrgb( vector inputColor )
{
	inputColor.x = (inputColor.x < 0.0031308) ? (inputColor.x > 0.0 ? inputColor.x * 12.92 : inputColor.x) : 1.055 * pow( inputColor.x, 1.0 / GAMMA ) - 0.055
	inputColor.y = (inputColor.y < 0.0031308) ? (inputColor.y > 0.0 ? inputColor.y * 12.92 : inputColor.y) : 1.055 * pow( inputColor.y, 1.0 / GAMMA ) - 0.055
	inputColor.z = (inputColor.z < 0.0031308) ? (inputColor.z > 0.0 ? inputColor.z * 12.92 : inputColor.z) : 1.055 * pow( inputColor.z, 1.0 / GAMMA ) - 0.055

	return inputColor
}










int function ConvertStringToInt( string str )
{
	Assert( str.isnumeric() )
	return int( str )
}

int ornull function DateTimeStringToUnixTimestamp( string str )
{
	str = strip( str )

	
	if ( str.isnumeric() )
		return int( str )

	
	string datetimeStringPattern = "2020-12-28 10:00:00 -08:00"

	if ( str.len() != datetimeStringPattern.len() )
		return null

	TimeParts parts
	parts.year = ConvertStringToInt(str.slice(0, 4))
	parts.month = ConvertStringToInt(str.slice(5, 7))
	parts.day = ConvertStringToInt(str.slice(8, 10))
	parts.hour = ConvertStringToInt(str.slice(11, 13))
	parts.minute = ConvertStringToInt(str.slice(14, 16))
	parts.second = ConvertStringToInt(str.slice(17, 19))
	int timezoneOffsetHours = ( str.slice(20, 21) == "-" ? -1 : 1 ) * ConvertStringToInt( str.slice(21, 23) )

	

	return GetUnixTimeFromParts( parts, timezoneOffsetHours ) 
}


int function GetUnixTimePST()
{
	int unixTime = GetUnixTimestamp()
	unixTime += (PST_TIME_ZONE_OFFSET * SECONDS_PER_HOUR)
	return unixTime
}


int function GetUnixTimePDT()
{
	int unixTime = GetUnixTimestamp()
	unixTime += (PDT_TIME_ZONE_OFFSET * SECONDS_PER_HOUR)
	return unixTime
}


TimeParts function GetUnixTimeParts( int unixtime, int timezoneOffsetHours = -7 )
{
	unixtime += SECONDS_PER_HOUR * timezoneOffsetHours

	
	TimeParts parts

	

	parts.second = unixtime % 60
	unixtime /= 60

	parts.minute = unixtime % 60
	unixtime /= 60

	parts.hour = unixtime % 24
	unixtime /= 24

	

	unixtime += 719499

	
	

	for ( parts.year = 1969 ; unixtime > __YearToDays( parts.year + 1 ) + 30; parts.year++ )
	{
	}

	
	unixtime -= __YearToDays( parts.year )

	

	
	for ( parts.month = 1 ; parts.month < 12 && unixtime > 367 * (parts.month + 1) / 12; parts.month++ )
	{
	}

	
	unixtime -= 367 * parts.month / 12

	

	
	parts.month += 2
	if ( parts.month > 12 )
	{
		parts.month -= 12
		parts.year++
	}

	parts.day = unixtime

	return parts
}


int function GetUnixTimeFromParts( TimeParts parts, int timezoneOffsetHours )
{
	int y                     = parts.year - (parts.month <= 2 ? 1 : 0)
	int era                   = (y >= 0 ? y : y - 399) / 400
	int yoe                   = y - era * 400 
	int doy                   = (153 * (parts.month + (parts.month > 2 ? -3 : 9)) + 2) / 5 + parts.day - 1 
	int doe                   = yoe * 365 + yoe / 4 - yoe / 100 + doy 
	int days_since_1970_01_01 = era * 146097 + doe - 719468

	return (SECONDS_PER_DAY * days_since_1970_01_01
	+ SECONDS_PER_HOUR * (parts.hour - timezoneOffsetHours)
	+ SECONDS_PER_MINUTE * parts.minute
	+ parts.second)
}


int function __YearToDays( int y )
{
	return (y) * 365 + (y) / 4 - (y) / 100 + (y) / 400
}


DisplayTime function SecondsToDHMS( int seconds )
{
	DisplayTime dt

	
	dt.days = int( floor( seconds / SECONDS_PER_DAY ) )

	
	int hourSeconds = seconds % SECONDS_PER_DAY
	dt.hours = int( floor( hourSeconds / SECONDS_PER_HOUR ) )

	
	int minuteSeconds = hourSeconds % SECONDS_PER_HOUR
	dt.minutes = int( floor( minuteSeconds / SECONDS_PER_MINUTE ) )

	
	int remainingSeconds = minuteSeconds % SECONDS_PER_MINUTE
	dt.seconds = int( ceil( remainingSeconds ) )

	return dt
}

string function GetDaysHoursRemainingLoc(int days, int hours)
{
	string dateFormat = "#DAYS_HOURS_REMAINING"

	if ( hours == 1 )
	{
		dateFormat = "#DAYS_HOUR_REMAINING"
	}
	if ( days == 1 )
	{
		if ( hours == 1 )
		{
			dateFormat = "#DAY_HOUR_REMAINING"
		}
		else
		{
			dateFormat = "#DAY_HOURS_REMAINING"
		}
	}

	return dateFormat
}


string function GetDaysHoursMinutesSecondsString( int seconds )
{
	
	DisplayTime dt = SecondsToDHMS( seconds )
	return format( "%i:%02i:%02i.%02i", dt.days, dt.hours, dt.minutes, dt.seconds )
}


int function GetDayOfWeek( int unixTime )
{
	return int( (floor( unixTime / SECONDS_PER_DAY ) + 4) % 7 )
}


string function GetDayOfWeekName( int dayOfWeek )
{
	array<string> days = ["#SUNDAY", "#MONDAY", "#TUESDAY", "#WEDNESDAY", "#THURSDAY", "#FRIDAY", "#SATURDAY"]
	Assert( dayOfWeek >= 0 && dayOfWeek < days.len() )
	return days[dayOfWeek]
}


string function GetDateTimeString( int unixTime, int timezoneOffsetHours = -7 )
{
	TimeParts timeParts = GetUnixTimeParts( unixTime, timezoneOffsetHours )
	return format( "%04i-%02i-%02i %02i:%02i:%02i", timeParts.year, timeParts.month, timeParts.day, timeParts.hour, timeParts.minute, timeParts.second )
}


string function GetDateTimeStringNoYearNoSeconds( int unixTime, int timezoneOffsetHours = 0 )
{
	TimeParts timeParts = GetUnixTimeParts( unixTime, timezoneOffsetHours )
	return format( "%02i/%02i %02i:%02i", timeParts.month, timeParts.day, timeParts.hour, timeParts.minute )
}


string function GetTimeString( int unixTime )
{
	TimeParts timeParts = GetUnixTimeParts( unixTime )
	return format( "%02i:%02i:%02i", timeParts.hour, timeParts.minute, timeParts.second )
}

string function GetDateTimeStringDayMonthYear( int unixTime, int timezoneOffsetHours = 0 )
{
	TimeParts timeParts = GetUnixTimeParts( unixTime, timezoneOffsetHours )
	return format( "%02i-%02i-%04i",  timeParts.day, timeParts.month, timeParts.year )
}



int function GetStartOfDay( int unixTime )
{
	TimeParts timeParts    = GetUnixTimeParts( unixTime )
	int unixTimeStartOfDay = unixTime
	unixTimeStartOfDay = unixTimeStartOfDay - (timeParts.hour * SECONDS_PER_HOUR) - (timeParts.minute * SECONDS_PER_MINUTE) - timeParts.second
	return unixTimeStartOfDay
}


int function GetEndOfDay( int unixTime )
{
	return GetStartOfDay( unixTime + SECONDS_PER_DAY )
}


int function SecondsRemainingInDay( int unixTime )
{
	int endOfDay = GetEndOfDay( unixTime )
	return endOfDay - unixTime
}


void function WaitForUnixTime( int unixTime )
{
	while ( true )
	{
		float delay = float(unixTime - GetUnixTimestamp())
		if ( delay <= 0.0 )
			break

#if DEV
			wait min( 1.0, delay )
#else
			wait delay
#endif
	}
}



bool function CanSendFriendRequest( entity player )
{
	if ( !GetCurrentPlaylistVarBool( "enable_squad_friend_invite", true ) )
		return false

	return true
}

bool function CanInviteSquadMate( string uid )
{
	if ( !GetCurrentPlaylistVarBool( "enable_squad_invite", true ) )
		return false

	if ( IsInMyParty( uid ) )
		return false

	if ( GetParty().numFreeSlots == 0 )
		return false

	return true
}

bool function IsInMyParty( string uid )
{
	Party party = GetParty()
	foreach ( p in party.members )
	{
		if ( p.uid == uid )
			return true
	}
	return false
}




WaitQuotaItem function WaitFrameQuota_Init( int maxPerFrame )
{
	WaitQuotaItem wq
	wq._count = 0
	wq._budget = maxPerFrame
	return wq
}


void function WaitFrameQuota_Reset( WaitQuotaItem wq )
{
	wq._count = 0
}


void function WaitFrameQuota( WaitQuotaItem wq )
{
	wq._count += 1
	if ( wq._count < wq._budget )
		return
	wq._count = 0
	WaitFrame()
}


entity function AssertLocalOrServerValidPlayer( entity player )
{



		if ( player == null )
			player = GetLocalClientPlayer()
		Assert( player == GetLocalClientPlayer() )


	return player
}


bool function IsEverythingUnlocked()
{
#if DEV
		if ( GetCurrentPlaylistVarBool( "dev_force_everything_unlocked", false ) )
			return true
#endif

	return EverythingUnlockedConVarEnabled()
}


string function StripRuiStringFormatting( string text )
{
	string newText = text
	while ( newText.find( "`" ) != -1 )
	{
		int idx = newText.find( "`" )

		if ( newText.len() < 2 )
			return ""

		string a = ""

		if ( idx > 0 )
		{
			a = newText.slice( 0, idx )
		}

		string b = ""

		if ( idx + 2 < newText.len() )
		{
			b = newText.slice( idx + 2, newText.len() )
		}

		newText = a + b
	}

	return newText
}









var function GetRandomWeighted( ... )
{
	Assert( vargc % 2 == 0, "Must pass pairs to GetRandomWeighted!" )
	float total = 0.0
	for ( int argIdx = 0; argIdx < vargc; argIdx += 2 )
		total += expect float(vargv[argIdx + 0])

	float choice = RandomFloat( total )
	total = 0.0
	for ( int argIdx = 0; argIdx < vargc; argIdx += 2 )
	{
		total += expect float(vargv[argIdx + 0])
		if ( choice < total )
			return vargv[argIdx + 1]
	}

	Assert( false )
	return null
}

















































































































void function WaitSignals( var obj, array<string> signals )
{
	Assert( signals.len() > 0 )
	waitthread __WaitSignalsInternal( obj, signals )
}


void function __WaitSignalsInternal( var obj, array<string> signals )
{
	foreach ( string signal in signals )
		EndSignal( obj, signal )
	WaitForever()
}


void function WaitEndSignal( var obj, string signal )
{
	waitthread __WaitEndSignalInternal( obj, signal )
}


void function __WaitEndSignalInternal( var obj, string signal )
{
	EndSignal( obj, signal )
	WaitForever()
}













































































































































vector function DirFBLRUD_ToDir( DirFBLRUD dir )
{
	switch ( dir )
	{
		case DIR_FBLRUD_FORWARD:
			return <1, 0, 0>

		case DIR_FBLRUD_BACK:
			return <-1, 0, 0>

		case DIR_FBLRUD_LEFT:
			return <0, 1, 0>

		case DIR_FBLRUD_RIGHT:
			return <0, -1, 0>

		case DIR_FBLRUD_UP:
			return <0, 0, 1>

		case DIR_FBLRUD_DOWN:
			return <0, 0, -1>
	}
	Assert( false, "Bad direction: " + dir )
	return <0, 0, 0>
}




float function DirFBLRUD_ForwardLength( DirFBLRUD dir, vector vec )
{
	switch ( dir )
	{
		case DIR_FBLRUD_FORWARD:
			return vec.x

		case DIR_FBLRUD_BACK:
			return -1.0 * vec.x

		case DIR_FBLRUD_LEFT:
			return vec.y

		case DIR_FBLRUD_RIGHT:
			return -1.0 * vec.y

		case DIR_FBLRUD_UP:
			return vec.z

		case DIR_FBLRUD_DOWN:
			return -1.0 * vec.z
	}
	Assert( false, "Bad direction: " + dir )
	return 0.0
}




void functionref( bool success ) MenuExtendedUse_callback = null
void function StartMenuExtendedUse( var focusElem, var holdToUseElem, float duration, bool requireControllerFocus, bool isAltAction, void functionref( bool success ) callback,
string loopSound = "survival_titan_linking_loop", string successSound = "ui_menu_store_purchase_success" )
{
	
	if ( MenuExtendedUse_callback != null )
		return

	MenuExtendedUse_callback = callback

		bool isForClientVM = false
		thread _MenuExtendedUse_InternalThread( focusElem, holdToUseElem, duration, loopSound, successSound, isForClientVM, requireControllerFocus, isAltAction )



}




void function _ClientToUI_MenuExtendedUseBegin( var focusElem, var holdToUseElem, float duration, string loopSound, string successSound, bool requireControllerFocus, bool isAltAction )
{
	bool isForClientVM = true
	thread _MenuExtendedUse_InternalThread( focusElem, holdToUseElem, duration, loopSound, successSound, isForClientVM, requireControllerFocus, isAltAction )
}











bool _MenuExtendedUse_InternalThread_isActive = false
void function _MenuExtendedUse_InternalThread( var focusElem, var holdToUseElem, float duration, string loopSound, string successSound, bool isForClientVM, bool requireControllerFocus, bool isAltAction )
{
	
	if ( _MenuExtendedUse_InternalThread_isActive )
		return
	_MenuExtendedUse_InternalThread_isActive = true

	Hud_Show( holdToUseElem )
	HideGameCursor()

	var rui = Hud_GetRui( holdToUseElem )
	RuiSetBool( rui, "isVisible", true )
	RuiSetGameTime( rui, "startTime", ClientTime() )
	RuiSetFloat( rui, "duration", duration )
	RuiSetString( rui, "holdButtonHint", isAltAction ? "%[X_BUTTON|MOUSE2]%" : "%[A_BUTTON|MOUSE1]%" )

	float uiEndTime = ClientTime() + duration

	if ( loopSound != "" )
		EmitUISound( loopSound )

	bool[1] success = [false]

	OnThreadEnd( void function() : ( loopSound, rui, holdToUseElem, isForClientVM, success ) {
		ShowGameCursor()
		Hud_Hide( holdToUseElem )
		RuiSetBool( rui, "isVisible", false )
		if ( loopSound != "" )
			StopUISound( loopSound )

		if ( isForClientVM && CanRunClientScript() )
		{
			RunClientScript( "_UIToClient_MenuExtendedUseEnded", success[0] )
		}
		else
		{
			Assert( MenuExtendedUse_callback != null )
			MenuExtendedUse_callback( success[0] )
			MenuExtendedUse_callback = null
		}

		_MenuExtendedUse_InternalThread_isActive = false
	} )

	while ( true )
	{
		bool isButtonHeld = false
		if ( InputIsButtonDown( MOUSE_LEFT ) || InputIsButtonDown( BUTTON_A ) )
			isButtonHeld = true

		bool allowRightClick = true
		if ( allowRightClick && (InputIsButtonDown( MOUSE_RIGHT ) || InputIsButtonDown( BUTTON_X )) )
			isButtonHeld = true

		if ( !isButtonHeld )
			break

		if ( ClientTime() >= uiEndTime )
			break

		if ( GetMouseFocus() != focusElem && !GetDpadNavigationActive() )
		{
			if ( IsControllerModeActive() && requireControllerFocus )
				break
			else if ( !IsControllerModeActive() )
				break
			
		}

		vector screenPos = ConvertCursorToScreenPos()
		Hud_SetPos( holdToUseElem, screenPos.x - Hud_GetWidth( holdToUseElem ) * 0.5, screenPos.y - Hud_GetHeight( holdToUseElem ) * 0.5 )
		WaitFrame()
	}

	if ( ClientTime() < uiEndTime )
		return

	if ( IsLobby() )
		return

	if ( successSound != "" )
		EmitUISound( successSound )
	success[0] = true
}




bool function IsInfiniteAmmoEnabled()
{
#if DEV
		if ( GetConVarBool( "sv_infinite_ammo" ) )
			return true
#endif
	return false
}












void function SetConVarFloatFromPlaylist( string varName, float floatVal )
{
	SetConVarFloat( varName, GetCurrentPlaylistVarFloat( varName, floatVal ) )
}



bool function IsUserOnSamePlatform( string hardware )
{

		return hardware == GetUnspoofedPlayerHardware()





}

bool function IsUserOnSamePlatformID( int hardwareID )
{

		int localPlayerHardwareID = GetHardwareFromName( GetUnspoofedPlayerHardware() )
		if( ( hardwareID == HARDWARE_PS4 || hardwareID == HARDWARE_PS5 ) && (localPlayerHardwareID == HARDWARE_PS4 || localPlayerHardwareID == HARDWARE_PS5) )
		{
			return true
		}
		else if( ( hardwareID == HARDWARE_XBOXONE || hardwareID == HARDWARE_XB5 ) && (localPlayerHardwareID == HARDWARE_XBOXONE || localPlayerHardwareID == HARDWARE_XB5) )
		{
			return true
		}
		else
		{
			return hardwareID == GetHardwareFromName( GetUnspoofedPlayerHardware() )
		}
		return false






















}

bool function CrossplayUserOptIn()
{
	return IsUserOptedInToCrossPlay() && CrossplayEnabled()
}


bool function CrossplayEnabled()
{
	return GetConVarInt( "crossPlay_enabled" ) != 0
}

string function PlatformIDToIconString( int platformID )
{
	if ( IsUserOnSamePlatformID( platformID ) )
	{
		switch ( platformID )
		{
			case HARDWARE_PC:

			case HARDWARE_PC_STEAM:

				return Localize( "#CROSSPLAY_ICON_PC" )

			case HARDWARE_PS4:
			case HARDWARE_PS5:
				return Localize( "#CROSSPLAY_ICON_PS4" )

			case HARDWARE_XBOXONE:
			case HARDWARE_XB5:
				return Localize( "#CROSSPLAY_ICON_XBOX" )

			case HARDWARE_SWITCH:
				return Localize( "#CROSSPLAY_ICON_NX" )

			default:
				return ""
		}
	}
	else
	{
		switch ( platformID )
		{
			case HARDWARE_PC:

			case HARDWARE_PC_STEAM:

				return Localize( "#CROSSPLAY_ICON_PC" )

			case HARDWARE_PS4:
			case HARDWARE_XBOXONE:
			case HARDWARE_SWITCH:
			case HARDWARE_XB5:
			case HARDWARE_PS5:
				return Localize( "#CROSSPLAY_ICON_CONTROLLER" )

			default:
				return ""
		}
	}

	Assert( false, "Unhandled platformID " + platformID )
	unreachable
}



bool function AreClubInvitesEnabled()
{
	return GetConVarInt( "clubs_showInvites" ) == eClubInviteDisplayLevel.ENABLED
}










































































































































































































































































































































































































bool function IsPlayerOneOfCharacters( entity player, array< string > charactersCheck )
{
	ItemFlavor character = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_Character() )
	string characterRef  = ItemFlavor_GetCharacterRef( character ).tolower()

	foreach ( characterCheck in charactersCheck )
	{
		if ( characterRef == characterCheck )
			return true
	}

	return false
}

bool function IsPlayerCharacter( entity player, string characterCheck )
{
	ItemFlavor character = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_Character() )
	string characterRef  = ItemFlavor_GetCharacterRef( character ).tolower()

	if ( characterRef != characterCheck )
		return false

	return true
}
